// Copyright (c) 2015 Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"
#include "../SL/common.sl"
#include "../SL/states.sl"
#include "../SL/noise.sl"
#include "../SL/noise_constants.sl"
#include "../SL/common.sl"

uniform Texture2D noise_texture SIMUL_TEXTURE_REGISTER(0);
uniform Texture3D random_texture_3d SIMUL_TEXTURE_REGISTER(1);
uniform RWTexture3D<vec4> targetTexture32 SIMUL_RWTEXTURE_REGISTER(0);
uniform RWTexture3D<char4> targetTexture8 SIMUL_RWTEXTURE_REGISTER(1);

SamplerState samplerState 
{
	Filter = MIN_MAG_MIP_LINEAR;
	AddressU = Wrap;
	AddressV = Wrap;
};

struct a2v
{
    vec4 position  : POSITION;
    vec2 texCoords  : TEXCOORD0;
};

vec4 VirtualNoiseLookup(vec3 texCoords,int gridsize,int seed)
{
	vec4 result		=vec4(0,0,0,0);
	vec3 pos		=texCoords*gridsize;
	vec3 intpart,floatpart;
	floatpart		=modf(pos,intpart);
	int3 seedpos	=int3(1*seed,2*seed,3*seed);
	int3 firstCorner=int3(intpart);
    for (int i = 0; i < 2; i++)
	{
        for (int j  = 0; j < 2; j++)
		{
            for (int k  = 0; k < 2; k++)
			{
				int3 corner_pos		=firstCorner+int3(1-i,1-j,1-k);
				// NOTE: operator % does NOT seem to work properly here.
				if(corner_pos.x==gridsize)
					corner_pos.x=0;
				if(corner_pos.y==gridsize)
					corner_pos.y=0;
				if(corner_pos.z==gridsize)
					corner_pos.z=0;
				vec3 lookup_pos		=seedpos+vec3(corner_pos);
				vec4 rnd_lookup		=vec4(SphericalRandom(lookup_pos),rand3(lookup_pos));
				float proportion	=abs(i-floatpart.x)*abs(j-floatpart.y)*abs(k-floatpart.z);
				result				+=rnd_lookup*proportion;
			}
		}
	}
	return result;
}


vec4 Noise3D(int freq,vec3 texCoords,int octaves,float persistence)
{
	vec4 result		=vec4(0,0,0,0);
	float mult		=0.5;
	float total		=0.0;
	float prevx		=1.0;
	vec3 last;
	int grid		=freq;
    for(int i=0;i<octaves;i++)
    {
		vec4 c		=VirtualNoiseLookup(texCoords,grid,i);
		texCoords	*=2.0;
		total		+=mult;
		result		+=mult*c;
		mult		*=persistence;
		prevx		=c.a;
		last		=c.rgb;
		grid		*=2;
    }
	// divide by total to get the range -1,1.
	result			/=total;
	result			=clamp(result,vec4(-1.0,-1.0,-1.0,-1.0),vec4(1.0,1.0,1.0,1.0));
	return result;
}

shader vec4 RandomPS(posTexVertexOutput IN) : SV_TARGET
{
	// Range from -1 to 1.
	vec4 c=2.0*vec4(rand(IN.texCoords),rand(1.7*IN.texCoords),rand(0.11*IN.texCoords),rand(513.1*IN.texCoords))-1.0;
	//vec4 c=vec4(SphericalRandom(IN.texCoords),2.0*rand(513.1*IN.texCoords)-1.0);
    return c;
}

shader vec4 NoisePS(posTexVertexOutput IN) : SV_TARGET
{
    return Noise(noise_texture,IN.texCoords,persistence,octaves);
}

CS_LAYOUT(8,8,8)
shader void CS_Random3D(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 pos = g * 8 + t;
	int3 dims=int3(noise_texture_size,noise_texture_size,noise_texture_size);
	//targetTexture32.GetDimensions(dims.x,dims.y,dims.z);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	vec3 texCoords			=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
	vec2 texc2				=texCoords.xy+dims.y*texCoords.z;
	// Range from -1 to 1.
	vec4 c					=vec4(SphericalRandom(texCoords),rand3(513.1*texCoords));
   // vec4 c				=2.0*vec4(rand(texc2),rand(1.7*texc2),rand(0.11*texc2),rand(513.1*texc2))-vec4(1.0,1.0,1.0,1.0);
    IMAGE_STORE_3D(targetTexture32,pos,c.xyzw);
}

CS_LAYOUT(8,8,8)
shader void CS_Random3D_8(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 pos = g * 8 + t;
	int3 dims=int3(noise_texture_size,noise_texture_size,noise_texture_size);
	//targetTexture32.GetDimensions(dims.x,dims.y,dims.z);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	vec3 texCoords			=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
	vec2 texc2				=texCoords.xy+dims.y*texCoords.z;
	// Range from -1 to 1.
	vec4 c					=vec4(SphericalRandom(texCoords),rand3(513.1*texCoords));
   // vec4 c				=2.0*vec4(rand(texc2),rand(1.7*texc2),rand(0.11*texc2),rand(513.1*texc2))-vec4(1.0,1.0,1.0,1.0);
    IMAGE_STORE_3D(targetTexture8,pos,c.xyzw);
}

CS_LAYOUT(8,8,8)
shader void CS_Noise3D_8(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 pos = g * 8 + t;
	int3 dims=int3(noise_texture_size,noise_texture_size,noise_texture_size);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	vec3 texCoords		=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
	vec4 result			=Noise3D(noise_texture_frequency,texCoords,octaves, persistence);
	IMAGE_STORE_3D(targetTexture8,pos,result);
}

CS_LAYOUT(8,8,8)
shader void CS_Noise3D_float(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 pos		=g*8+t;
	int3 dims		=int3(noise_texture_size,noise_texture_size,noise_texture_size);
	//targetTexture32.GetDimensions(dims.x,dims.y,dims.z);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	vec3 texCoords	=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
	vec4 result		=Noise3D(noise_texture_frequency,texCoords,octaves, persistence);//texture_wrap_lod(random_texture_3d,texCoords,0);//
	//result=vec4(1.0,0,0,0);
    IMAGE_STORE_3D(targetTexture32,pos,result);
}

float Worley(vec3 texc,int grid,int seed)
{
	vec3 pos			=float(grid)*texc;
	vec3 fractional,intpart;
	fractional			=modf(pos,intpart);
	int3 ip				=int3(intpart);
	vec3 loc			=fractional-vec3(0.5,0.5,0.5);
	float n				=float(grid);
    for (int i = -1; i < 2; ++i)
	{
        for (int j = -1; j < 2; ++j)
		{
            for (int k = -1; k < 2; ++k)
			{
				vec3 c		=vec3(i,j,k);
				int3 u		=(ip+int3(i,j,k));
				u			%=grid;
				vec3 random	=SphericalRandom(vec3(u)*seed);
				c			+=random.xyz;
				float k1	=length(loc-c);
				n			=min(n,k1);
			}
		}
	}
	float p			=saturate(1.0-pow(n,1.0))/1.0;
	return p;
}

CS_LAYOUT(8,8,8)
shader void CS_PerlinWorley3D_8(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 idx = g * 8 + t;
	int3 dims=int3(noise_texture_size,noise_texture_size,noise_texture_size);
	if(idx.x>=dims.x||idx.y>=dims.y||idx.z>=dims.z)
		return;
	vec3 texCoords	=(vec3(idx)+vec3(0.5,0.5,0.5))/vec3(dims);
	vec4 result;
	result.xyzw		=Worley(texCoords,16,1);//saturate(Noise3D(noise_texture_frequency,texCoords,5, persistence).x+Worley(texCoords,16,1)-0.5);
	result.y		=Worley(texCoords,16,2);
	result.z		=Worley(texCoords,32,1);
	result.w		=Worley(texCoords,64,1);
	IMAGE_STORE_3D(targetTexture8,idx,result);
}

CS_LAYOUT(8,8,8)
shader void CS_Worley3D_8(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 idx = g * 8 + t;
	int3 dims=int3(noise_texture_size,noise_texture_size,noise_texture_size);
	if(idx.x>=dims.x||idx.y>=dims.y||idx.z>=dims.z)
		return;
	vec3 texCoords		=(vec3(idx)+vec3(0.5,0.5,0.5))/vec3(dims);
	int grid=8;
	vec4 result;
	result.x		=Worley(texCoords,5,1);
	result.y		=Worley(texCoords,9,2);
	result.z		=Worley(texCoords,16,3);
	result.w		=Worley(texCoords,24,4);
	IMAGE_STORE_3D(targetTexture8,idx,result);
}

CS_LAYOUT(4,4,4)
shader void CS_MakeMips3D_float(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 p = g * 8 + t;
	int3 pos	=int3(p);
	vec4 result	=TEXTURE_LOAD_3D(random_texture_3d,pos*2);
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(0,1,0));
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(1,0,0));
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(1,1,0));
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(0,0,1));
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(0,1,1));
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(1,0,1));
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(1,1,1));
	result		/=8.0;
	//result=vec4(1.0,0,0,0);
    IMAGE_STORE_3D(targetTexture32,pos,result);
}

DepthStencilState DisableDepth
{
	DepthEnable = FALSE;
	DepthWriteMask = ZERO;
};

RasterizerState RenderNoCull
{
	CullMode = none;
};

BlendState NoBlend
{
	BlendEnable[0] = FALSE;
};

technique simul_random
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		//SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_SimpleFullscreen()));
		SetPixelShader(CompileShader(ps_4_0,RandomPS()));
    }
}

technique simul_noise_2d
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		//SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_SimpleFullscreen()));
		SetPixelShader(CompileShader(ps_4_0,NoisePS()));
    }
}

technique random_3d_compute
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Random3D()));
    }
}

technique random_3d_compute_8bit
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Random3D_8()));
    }
}


technique noise_3d_compute_8bit
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Noise3D_8()));
    }
}

technique noise_3d_compute_float
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Noise3D_float()));
    }
}

technique perlin_worley_3d_compute_8bit
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_PerlinWorley3D_8()));
    }
}

technique worley_3d_compute_8bit
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Worley3D_8()));
    }
}
technique make_mip_3d
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_MakeMips3D_float()));
    }
}


/*
float noise(vec3 p);
float noise(vec2 p);

vec2 Rot(vec2 p, float t)
{
	float c = cos(t); float s = sin(t);
	return vec2(p.x*c+p.y*s,
				-p.x*s+p.y*c);
}

vec2 RotCS(vec2 p, float c, float s)
{
	return vec2( p.x*c+p.y*s,
				-p.x*s+p.y*c);
}
float pot(vec2 pos)
{
	float t = iGlobalTime*.1;

	vec3 p = vec3(pos+vec2(iGlobalTime*.4,0.),t);
	
	float n = noise(p);
	n += 0.5 *noise(p*2.13);
	n += 3. * noise(pos*0.333);
	
	return n;
}

vec2 field(vec2 pos)
{
	float s = 1.5;
	pos *= s;
	
	float n = pot(pos);
	
	float e = 0.1;
	float nx = pot(vec2(pos+vec2(e,0.)));
	float ny = pot(vec2(pos+vec2(0.,e)));
	
	return vec2(-(ny-n),nx-n)/e;
}


void mainImage( out vec4 fragColor, in vec2 fragCoord ) 
{
	float lod = 0.;
	
	vec2 uv = fragCoord.xy;
	uv /= iResolution.xy;
	uv.x *= iResolution.x/iResolution.y;
	uv.y = 1. - uv.y;
	vec2 src_uv = uv;
	
	vec3 d = vec3(0.);
	vec3 e = vec3(0.);
	for (int i=0; i<25; i++)
	{
		d += texture2D(iChannel0,uv+iGlobalTime*0.05,lod).xyz;
		e += texture2D(iChannel0,-uv.yx*3.+iGlobalTime*0.0125,lod).xyz;
		
		vec2 new_uv = field(uv)*.00625*.5;
	
		lod += length(new_uv)*5.;
		uv += new_uv;
	}
	

	vec3 c = texture2D(iChannel0,uv*.1+iGlobalTime*0.025,lod).xyz;

	d *= (1./50.);
	e *= (1./50.);
	c = mix(c,d,length(d));
	c = mix(c,e,length(e));

	fragColor = vec4( c,1);

}

//  pseudorandom uniformly distributed in [-0.5, +0.5]^3 
vec3 random3(vec3 c){
	float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
	vec3 r;
	r.z = fract(512.0*j);
	j *= .125;
	r.x = fract(512.0*j);
	j *= .125;
	r.y = fract(512.0*j);
	r = r-0.5;
	
	//rotate for extra flow!
	float t = -iGlobalTime*.5;
	r.xy = Rot(r.xy,t);

	
	return r;
}

// skew constants
const float F3 =  0.3333333;
const float G3 =  0.1666667;

// 3d simplex noise
float noise(vec3 p)
{
	 // 1. find current tetrahedron T and its four vertices 
	 // s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices 
	 // x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices
	 
	 // calculate s and x 
	 vec3 s = floor(p + dot(p, vec3(F3)));
	 vec3 x = p - s + dot(s, vec3(G3));
	 
	 // calculate i1 and i2 
	 vec3 e = step(vec3(0.0), x - x.yzx);
	 vec3 i1 = e*(1.0 - e.zxy);
	 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
	 	
	 // x1, x2, x3 
	 vec3 x1 = x - i1 + G3;
	 vec3 x2 = x - i2 + 2.0*G3;
	 vec3 x3 = x - 1.0 + 3.0*G3;
	 	
	 // 2. find four surflets and store them in d 
	 vec4 w, d;
	 
	 // calculate surflet weights 
	 w.x = dot(x, x);
	 w.y = dot(x1, x1);
	 w.z = dot(x2, x2);
	 w.w = dot(x3, x3);
	 
	 // w fades from 0.6 at the center of the surflet to 0.0 at the margin 
	 w = max(0.6 - w, 0.0);
	 
	 // calculate surflet components 
	 d.x = dot(random3(s), x);
	 d.y = dot(random3(s + i1), x1);
	 d.z = dot(random3(s + i2), x2);
	 d.w = dot(random3(s + 1.0), x3);
	 
	 // multiply d by w^4 
	 w *= w;
	 w *= w;
	 d *= w;
	 
	 // 3. return the sum of the four surflets 
	 return dot(d, vec4(52.0));
}


// 2d simplex noise
vec2 hash( vec2 p )
{
	p = vec2( dot(p,vec2(127.1,311.7)),
			  dot(p,vec2(269.5,183.3)) );

	vec2 h = -1.0 + 2.0*fract(sin(p)*43758.5453123);

#if 1	
	//extra rotations for more flow!
	float t = -iGlobalTime*0.7;
	float co = cos(t); float si = sin(t);	
	h = RotCS(h,co,si);
#endif
	return h;
}


float noise( in vec2 p )
{
    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
    const float K2 = 0.211324865; // (3-sqrt(3))/6;

	vec2 i = floor( p + (p.x+p.y)*K1 );
	
    vec2 a = p - i + (i.x+i.y)*K2;
    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));
    vec2 b = a - o + K2;
	vec2 c = a - 1.0 + 2.0*K2;

#if 1	
	// extra rotations for more flow
	float t = iGlobalTime*.5;
	float co = cos(t); float si = sin(t);	
	a = RotCS(a,co,si);
	b = RotCS(b,co,si);
	c = RotCS(c,co,si);
#endif
	
    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );

	vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));

    return dot( n, vec3(70.0) );
	
}

*/