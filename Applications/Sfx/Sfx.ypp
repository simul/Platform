%define api.prefix {sfx}
%define parse.error verbose
%define parse.trace

%{
	#include <iostream>
	#include <map>
	#include <string>
	#include <vector>
	#include <sstream>
	#include <algorithm>
	#include <regex>
	
	#include "Sfx.h"
	#include "SfxClasses.h"

	using namespace std;
	using namespace  sfx;
	
	#ifdef _MSC_VER
	// MS's C++ compiler is more strict than gcc
	
	// bison related
	// Disable the warning about default being present but no other cases in switch
	#pragma warning( disable:4065 )

	// No unistd.h (for flex)
	#define YY_NO_UNISTD_H
		#define YYERROR_VERBOSE
	#endif

	#include "SfxScanner.h"
	#include "SfxEffect.h"
	#include "StringFunctions.h"
	extern int insert_line_statement;
	extern int yy_start;
	static void errSyn(const char *e);
	void errSem(const string& str, int line=-1);
	Function buildFunction;
	Struct buildStruct;
	RenderTargetFormatState buildrtFormatState;
	RasterizerState buildRasterizerState;
	BlendState buildBlendState;
	DepthStencilState buildDepthStencilState;
	SamplerState buildSamplerState;
	PassState buildPassState;
	RaytraceHitGroup buildRaytraceHitGroup;
	TechniqueGroup buildGroup;
	string currentTechniqueGroup;
	static int last_linenumber=0;
	static int current_filenumber=0;
	std::string current_filename;
	static int global_linenumber=0;
	std::string currentCsLayout;
	std::string currentGsLayout;
	bool sfxError=false;

	bool is_equal(const string& a, const char * b)
	{
		unsigned int sz = (unsigned int)a.size();
		if (strlen(b) != sz)
			return false;
		for (unsigned int i = 0; i < sz; ++i)
			if (tolower(a[i]) != tolower(b[i]))
				return false;
		return true;
	}
	bool toBool(const string &str)
	{
		if(is_equal(str,"TRUE"))
			return true;
		else if(is_equal(str,"FALSE"))
			return false;
		else errSem("Expected boolean.");
		return false;
	}
	bool IsRW(int token);
	bool IsArray(int token);
	bool IsCubemap(int token);

	static bool write_line_number_next=false;
	static void Skip()
	{
		write_line_number_next=true;
	}
	void WriteLineNumber(std::ostringstream &str,const std::string &filename,int lineno)
	{
		if(!lineno)
			return;
		std::string f=filename;
		size_t p=f.find("\\");
		while(p<f.length())
		{
			f=f.replace(f.begin()+p,f.begin()+p+1,"/");
			p=f.find("\\");
		}
		if (gEffect->GetOptions()->disableLineWrites)
			str<<"//";
		str<<"#line "<<lineno<<" "<<gEffect->GetFilenameOrNumber(f)<<endl;
	}
	void WriteLineNumber(std::ostringstream &str,int lineno)
	{
		WriteLineNumber(str,current_filename,lineno);//.c_str()<<"\""<<endl;
	}
	std::string CreateLineStatement(int lineno)
	{
		ostringstream ostr;
		ostr<<"\n";
		WriteLineNumber(ostr,current_filename,lineno+last_linenumber-global_linenumber);
		return ostr.str();
	}
	void stringReplaceAll(std::string& str, const std::string& from, const std::string& to)
	{
		if (from.empty())
			return;
		size_t start_pos = 0;
		while ((start_pos = str.find(from, start_pos)) != std::string::npos)
		{
			str.replace(start_pos, from.length(), to);
			start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'
		}
	}
	ShaderResourceType ToShaderResourceType(int t);
	ShaderResourceType GetShaderResourceType(const Function &function, const string &textureName);
	bool IsRW(ShaderResourceType t);
	bool IsMSAATexture(ShaderResourceType t);

	string GetSizeFunction(string textureName, string x, string y, string z);
	bool IsDeclared(string name)
	{
		if (gEffect->IsDeclared(name))
			return true;
		for (auto i = buildFunction.parameters.begin(); i != buildFunction.parameters.end(); i++)
		{
			if (i->identifier == name)
				return true;
		}
		return false;
	}
	void CallingFunction(const char *name)
	{
			const std::map<std::string,std::vector<Function*> > &functions=gEffect->GetFunctions();
			auto j=functions.find(name);
			for(auto u=j->second.begin();u!=j->second.end();u++)
				buildFunction.functionsCalled.insert(*u);
	}
	string GetDeclaredType(string name)
	{
		if (gEffect->IsDeclared(name))
			return gEffect->GetDeclaredType(name);
		for (auto i = buildFunction.parameters.begin(); i != buildFunction.parameters.end(); i++)
		{
			if (i->identifier == name)
				return i->type;
		}
		return "unknown";
	}
	int GetIndexOfParameter(const vector<sfxstype::variable> &parameters, const string &name)
	{
		for (int i = 0; i<parameters.size(); i++)
		{
			if (name == parameters[i].identifier)
				return i;
		}
		return -1;
	}

	string GetSamplerConstructor(ShaderResourceType t,string texName,Function* f)
	{
		string name = "null";
		auto config	= gEffect->GetConfig();
		if(!config->toTextureType.empty())
		{
			if(t == ShaderResourceType::UNKNOWN)
			{
				// We must know the type
				return string("{sampCons" + texName + "}");
			}
			auto declarations   = gEffect->GetDeclarations();
			auto dec			= declarations.find(texName);
			if(dec == declarations.end())
			{
				bool found = false;
				for(auto& p : f->parameters)
				{
					if(p.identifier == texName)
					{
						found = true;
						string searchT  = p.templ.empty() ? "default" : p.templ;
						auto stype	  = config->toTextureType.find(searchT);
						name			= stype->second;
						break;
					}
				}
				if(!found)
				{
					// It could not be ready yet:
					return string("{sampConsRIP" + texName + "}");
				}
			}
			else
			{
				auto td		 = (DeclaredTexture*)dec->second;
				string searchT  = td->structureType.empty() ? "default" : td->structureType;
				auto stype	  = config->toTextureType.find(searchT);
				if(stype==config->toTextureType.end())
				{
					string errstr="Unknown type for texture: ";
					errstr+=searchT+" ";
					errstr+=" - see toTextureType in config json.";
					errSyn(errstr.c_str());
				}
				name			= stype->second;
			}
			if((t & ShaderResourceType::TEXTURE_1D)==ShaderResourceType::TEXTURE_1D)
			{
				name += "1D";
			}
			if((t & ShaderResourceType::TEXTURE_2D) == ShaderResourceType::TEXTURE_2D)
			{
				name += "2D";
			}
			else if((t & ShaderResourceType::TEXTURE_3D) == ShaderResourceType::TEXTURE_3D)
			{
				name += "3D";
			}
			else if((t & ShaderResourceType::TEXTURE_CUBE) == ShaderResourceType::TEXTURE_CUBE)
			{
				name += "Cube";
			}
			// Handle MS
			if((t & ShaderResourceType::MS) == ShaderResourceType::MS)
			{
				name += "MS";
			}
			// Finally, array
			if((t & ShaderResourceType::ARRAY) == ShaderResourceType::ARRAY)
			{
				name += "Array";
			}
		}
		return name;
	}

	void GetInputs(std::ostringstream &inputs,vector<YYSTYPE::variable> *vars)
	{
		if(vars)
		for(vector<YYSTYPE::variable>::const_iterator it=vars->begin();it!=vars->end();++it)
		{
			if(it!=vars->begin())
				inputs<<", ";
			if(it->storage.length()>0)
				inputs<<it->storage<<' ';
			inputs<<it->type;
			if(it->templ.length()>0)
				inputs<<'<'<<it->templ<<'>';
			inputs<<' '<<it->identifier;
			if(it->num>0)
				inputs<<'['<<it->num<<']';
			if(it->semantic.length())
				inputs<<": "<<it->semantic;
			if (it->has_default)
				inputs << "=" << it->default_;
		}
	}

	string GetFixedParams(string params)
	{
		// TO-DO: why Nacho why ---> find_last_of find_last_of find_last_of find_last_of find_last_offind_last_of find_last_offind_last_offind_last_offind_last_offind_last_offind_last_offind_last_offind_last_offind_last_offind_last_offind_last_of
		string newParams;
		string copy(params);
		reverse(copy.begin(),copy.end());
		size_t parePos = copy.find(")");
		size_t comPos = copy.find(",");
		swap(copy[parePos],copy[comPos]);
		copy.insert(comPos,",");
		reverse(copy.begin(),copy.end());
		copy.erase(copy.size()-1);
		newParams = copy;

		// Fix the cast (now its one argument less)
		char castVals[] = {'2','3','4'};
		int icastVals[] = {2, 3, 4};
		for( int i = 0; i < 3; i++)
		{
			size_t valuePos = newParams.find(castVals[i]);
			if(valuePos != string::npos)
			{
				newParams.replace(newParams.begin() + valuePos,newParams.begin() + valuePos + 1,to_string(icastVals[i] - 1));
				break;
			}
		}

		return newParams;
	}
	
	string GetLoadExprMSAA(string textureName,string command,string params,ShaderResourceType resourceType,string pos,string idx)
	{
		auto config		= gEffect->GetConfig();
		string newParams= "ivec2(" + pos + ")," + "int(" + idx + ")";
		string newExpr	= config->loadSyntax;
		string samplerConstructor = GetSamplerConstructor(resourceType,textureName,&buildFunction);
		find_and_replace(newExpr,"{command}","texelFetch");
		if(config->combineInShader)
		{
			find_and_replace(newExpr,"{texture}", textureName );
		}
		else
		{
			find_and_replace(newExpr,"{texture}",samplerConstructor + "(" + textureName +"[0])");
		}
		find_and_replace(newExpr,"{params}",newParams);
		return newExpr;
	}

	string GetLoadExpr(string textureName,string command,string params,ShaderResourceType resourceType,bool with_mip=true)
	{
		auto config		= gEffect->GetConfig();
		int coord_size = 2;
		string newParams= params;
		string newExpr	= config->loadSyntax;

		if((resourceType & ShaderResourceType::TEXTURE_1D)== ShaderResourceType::TEXTURE_1D)
		{
			coord_size = 1;
		}
		if ((resourceType & ShaderResourceType::TEXTURE_3D) == ShaderResourceType::TEXTURE_3D)
		{
			coord_size = 3;
		}
		if ((resourceType & ShaderResourceType::ARRAY) == ShaderResourceType::ARRAY)
		{
			coord_size = 3;
		}

		// Select the command
		bool rw					 = IsRW(resourceType);
		string samplerConstructor   = "";
		if(rw)
		{
			find_and_replace(newExpr,"{command}","imageLoad");
		}
		else
		{
			find_and_replace(newExpr,"{command}","texelFetch");
			samplerConstructor = GetSamplerConstructor(resourceType,textureName,&buildFunction);
		}
		std::string mip;
		// Check the params
		if(coord_size == 1)
		{
			// gvec4 texelFetch(gsampler1D sampler,int P,int lod);
			newParams = "int(" + params + ").x,(" + params + ").y"; 
		}
		else if(coord_size == 2)
		{
			mip="int("+params+".z)";
			// gvec4 imageLoad(	gimage2D image,ivec2 P);
			if(rw)
				newParams = "ivec2(" + newParams + ").xy";
			else
			{
				newParams = ("ivec2(" + newParams + ").xy");
				if(with_mip)
					newParams=(newParams+",")+mip;
				else
					newParams=(newParams+",0");
			}
		}
		else if(coord_size == 3)
		{
			mip="int("+params+".w)";
			if(rw)
			{
				// gvec4 imageLoad(	gimage2DArray image,ivec3 P);
				newParams = "ivec3(" + newParams + ").xyz";
			}
			else
			{
				// gvec4 texelFetch( gsampler2DArray sampler,ivec3 P,int lod);
				newParams = ("ivec3(" + newParams + ").xyz");
				if(with_mip)
					newParams=(newParams+",")+mip;
				else
					newParams=(newParams+",0");
			}
		}
		else
		{
			newParams = "this shouldnt be here";
		}
		if(IsMSAATexture(resourceType))
		{
			// gvec4 texelFetch(gsampler2DMS sampler,ivec2 P,sample sample);
			newParams = params;
		}
		if(!samplerConstructor.empty())
		{
			if(config->combineInShader)
			{
				// Why would we be doing this??
				find_and_replace(newExpr,"{texture}",textureName);
			}
			else
			{
				find_and_replace(newExpr,"{texture}",samplerConstructor + "(" + textureName + "[0])"); 
			}
		}
		else
		{
			find_and_replace(newExpr,"{texture}",textureName);
		}
		find_and_replace(newExpr,"{params}",newParams);
		return newExpr;
	}

	void FinalizeFunction(Function& f)
	{
		f.min_parameters = 0;
		for (auto j : f.parameters)
		{
			if (!j.has_default)
			{
				f.min_parameters++;
			}
		}
		// Any resource that is not a parameter is therefore a global.
		for(auto i:f.resources)
		{
			string res_name=i;
			bool found=false;
			for(auto j:f.parameters)
			{
				if(j.identifier==res_name)
				{
					found=true;
					break;
				}
			}
			if(!found)
			for(auto j:f.locals)
			{
				if(j.identifier==res_name)
				{
					found=true;
					break;
				}
			}
			if(!found)
			{
				f.globals.insert(i);
			}
		}
		// texture load functions
		
		std::regex re("\\{load_expr ([a-z0-9_]+) ([a-z0-9_]+) ([^}]+) ([^}]+)? ([^}]+)?}", std::regex_constants::icase | std::regex::extended);
		std::smatch base_match;
		while (std::regex_search(f.content, base_match, re))
		{
			string result_expression;
			string textureName=base_match.str(1);
			string command=base_match.str(2);
			string params=base_match.str(3);
			string pos=base_match.str(4);
			string msaa_index=base_match.str(5);
			bool msaa=(msaa_index.length()>0);
			ShaderResourceType resourceType	= GetShaderResourceType(buildFunction,textureName);
			if(resourceType!=ShaderResourceType::UNKNOWN)
			{
				if(msaa)
				{
					result_expression+=GetLoadExprMSAA(textureName,command,params,resourceType,pos,msaa_index);
				}
				else
				{
					result_expression+=GetLoadExpr(textureName,command,params,resourceType);
				}
			}
			f.content = std::regex_replace(f.content, re, result_expression);
			base_match = std::smatch();
		}
		// Check and fix texture sampler constructors
		auto config	= gEffect->GetConfig();
		if(!config->toTextureType.empty())
		{
			for(auto j : f.parameters)
			{
				ShaderResourceType type = j.shaderResourceType;
				// At this point we must know the type!
				bool isTex = (type & ShaderResourceType::TEXTURE) == ShaderResourceType::TEXTURE;
				if(!isTex)
				{
					continue;
				}
				string toFind = "{sampCons" + j.identifier + "}";
				find_and_replace(f.content,toFind,GetSamplerConstructor(type,j.identifier,&f));

				// Also iterate over params (for MSAA)
				if((type & ShaderResourceType::MS) == ShaderResourceType::MS)
				{
					string mssaToFind = "{args" + j.identifier + "}";
					// TO-DO: In glsl, if we want to retrieve the sample of a mstexture
					// we need to call textureSamples(ms)
					find_and_replace(f.content,mssaToFind,"");
				}
				else
				{
					string mssaToFind = "{args" + j.identifier + "}";
					find_and_replace(f.content,mssaToFind,",0");
				}
				string dimToFind = "{dim:" + j.identifier + "}";
				find_and_replace(f.content,dimToFind,ToString(GetTextureDimension(j.shaderResourceType)));

				string dimCheckToFind = "{dim_check:" + j.identifier;
				size_t startPos = f.content.find(dimCheckToFind);
				size_t endPos = f.content.find_first_of("}", startPos);
				
				if (startPos != string::npos && endPos != string::npos)
				{
					auto findNextComma = [&](const size_t& currentPos)
					{
						size_t commaPos = f.content.find_first_of(",", currentPos);
						return commaPos > endPos ? endPos : commaPos;
					};

					size_t currentPos = startPos + dimCheckToFind.size() + 1;
					string x = string(f.content, currentPos, findNextComma(currentPos) - currentPos); currentPos = findNextComma(currentPos) + 1;
					string y = string(f.content, currentPos, findNextComma(currentPos) - currentPos); currentPos = findNextComma(currentPos) + 1;
					string z = string(f.content, currentPos, findNextComma(currentPos) - currentPos); currentPos = findNextComma(currentPos) + 1;
					string tempTextureName = string(f.content, currentPos, findNextComma(currentPos) - currentPos); currentPos = findNextComma(currentPos) + 1;

					string dimCheckReplace = "";
					int dim = GetTextureDimension(j.shaderResourceType);
					if (dim > 0 && x.size())
						dimCheckReplace += (x + " = " + tempTextureName + ".x;");
					if (dim > 1 && y.size())
						dimCheckReplace += (y + " = " + tempTextureName + ".y;");
					if (dim > 2 && z.size())
						dimCheckReplace += (z + " = " + tempTextureName + ".z;");

					f.content.replace(startPos, (endPos + 1) - startPos, dimCheckReplace);
				}
			}
			// We should check the globals too
			for(auto g : f.globals)
			{
				Declaration* d=gEffect->GetDeclaration(g);
				if(d&&d->declarationType == DeclarationType::TEXTURE)
				{
					DeclaredTexture* t = (DeclaredTexture*)d;
					if(t->type == "StructuredBuffer" || t->type == "RWStructuredBuffer")
					{
						// We dont want to mess with SB
						continue;
					}
					string toFind = "{sampCons" + t->name + "}";
					find_and_replace(f.content,toFind,GetSamplerConstructor(t->shaderResourceType,t->name,&f));
				}
			}
		}
	}
%}

%token SHADER PROGRAM INTERFACE IDENTIFIER STORAGEQ GL_FRAGDEPTH STORAGET SHADER_COMMAND SET_RASTERIZER_COMMAND SET_TOPOLOGY_COMMAND SET_DEPTH_COMMAND SET_BLEND_COMMAND SET_RTFORMAT_COMMAND
%token REGISTER NUM INCLUDE SAMPLER P_FLOAT CONST
%token NUM_THREADS MAX_VERTEX_COUNT LINE TECHNIQUE PASS RAYTRACE_PASS GROUP RENDER_STATE_DECL QUOTED_STRING SHADER_LINE SHADER_TYPE COMPILE_SHADER_INSTANCE CONSTRUCT_GS
%token DEFINE MACRO_DEFINITION EOL DECL_SHADER PROFILE
%token TEXTURE1D TEXTURE2D TEXTURE3D TEXTURE2D_ARRAY TEXTURE3D_ARRAY TEXTURECUBE TEXTURECUBE_ARRAY TEXTURE2DMS RW_TEXTURE1D RW_TEXTURE2D TEMPLATIZED_CONSTANT_BUFFER RAYTRACE_ACCELERATION_STRUCT RW_TEXTURE2D_ARRAY RW_TEXTURE3D RW_TEXTURE3D_ARRAY
%token REGULARBUFFER RW_REGULARBUFFER STRUCTUREDBUFFER RW_STRUCTUREDBUFFER
%token FILTER ADDRESS_U ADDRESS_V ADDRESS_W ADDRESS_WRAP ADDRESS_CLAMP ADDRESS_MIRROR FILTER_MIN_MAG_MIP_LINEAR FILTER_MIN_MAG_MIP_POINT FILTER_ANISOTROPIC

%token BREAK COMMENT CONTINUE DO ELSE FOR GOTO IF SWITCH CASE DEFAULT RETURN WHILE WHITESPACE
%token TIMES_EQUALS OVER_EQUALS PERCENT_EQUALS PLUS_EQUALS MINUS_EQUALS LEFT_SHIFT_EQUALS RIGHT_SHIFT_EQUALS AND_EQUALS XOR_EQUALS OR_EQUALS

%token AND OR LESS_EQ GRTR_EQ LEFT_SHIFT RIGHT_SHIFT PLUS_PLUS MINUS_MINUS EQ_EQ NOT_EQ COMPARISON D_NEVER D_ALWAYS D_LESS D_EQUAL D_LESS_EQUAL D_GREATER D_NOT_EQUAL D_GREATER_EQUAL

%token LOAD GET_DIMS SAMPLE SAMPLE_LOD
%token SATURATE 

%token STRUCT UNIFORM FLAT CONSTANT_BUFFER GROUPSHARED

%token SNORM UNORM

%token POINTLIST_TOPOLOGY LINELIST_TOPOLOGY LINESTRIP_TOPOLOGY TRIANGLELIST_TOPOLOGY TRIANGLESTRIP_TOPOLOGY LINELIST_ADJACENCY_TOPOLOGY LINESTRIP_ADJACENCY_TOPOLOGY TRIANGLELIST_ADJACENCY_TOPOLOGY TRIANGLESTRIP_ADJACENCY_TOPOLOGY

%token SET_RAY_GENERATION SET_MISS SET_CALLABLE SET_HIT_GROUP SET_CLOSEST_HIT SET_ANY_HIT SET_INTERSECTION SET_MISS_SHADERS SET_CALLABLE_SHADERS SET_RAY_TRACING_SHADER_CONFIG SET_RAY_TRACING_PIPELINE_CONFIG SET_MAX_PAYLOAD_SIZE SET_MAX_ATTRIBUTE_SIZE SET_MAX_TRACE_RECURSION_DEPTH
%%

prog : prog tok
	| %empty
	{ // Initialization code
		gEffect->m_sharedCode.str("");	// clear the stream
		gLexPassthrough=false;
	};
tok : INTERFACE lex_fx IDENTIFIER read_block ';' lex_passthrough
	{
		gEffect->m_interfaces[$3.strs[0]]=Effect::InterfaceDcl($4.strs[0], $1.lineno);
	}
	| EOL
	{
	}
	| line_statement
	{
	}
	| declaration_or_function
	{
	}
	| RENDER_STATE_DECL IDENTIFIER lex_fx optional_register_semantic lex_passthrough optional_renderstate_def ';' 
	{
		$$.lineno			=$5.lineno;
		RenderStateType t	=renderStateType;
		string type			=$1.strs[0];
		string name			=$2.strs[0];
		string semantic		=$4.strs[0];
		int register_number	=$4.num;
		string def			=$6.strs[0];
		if(t==RENDERTARGETFORMAT_STATE)
		{
			RenderTargetFormatState* fs	= gEffect->DeclareRenderTargetFormatState(name);
			*fs							= buildrtFormatState;
			fs->name					= name;
			buildrtFormatState			= RenderTargetFormatState();
		}
		if(t==RASTERIZER_STATE)
		{
			RasterizerState *rs	=gEffect->DeclareRasterizerState(name);
			*rs					=buildRasterizerState;
			// Set to default:
			buildRasterizerState=RasterizerState();
		}
		if(t==SAMPLER_STATE)
		{
			SamplerState *ss=gEffect->DeclareSamplerState(name,register_number,buildSamplerState);
			ss->global_line_number	=$1.lineno;
			// Set to default:
			buildSamplerState=SamplerState();
			const SfxConfig *config					=gEffect->GetConfig();
			if(config->passThroughSamplers)
			{
				if(config->samplerDeclaration.size() > 0)
				{
					string s=config->samplerDeclaration;
					find_and_replace(s,"{name}",name);
					find_and_replace(s,"{slot}",ToString(gEffect->GenerateSamplerSlot(ss->register_number)));
					find_and_replace(s,"{type}",type);
					gEffect->m_sharedCode<<s<<"\n";
				}
				else
				{
					gEffect->m_sharedCode<<type<<" "<<name<<" "<<semantic<<"\n{\n"<<def<<"\n};\n";
				}
			}
		}
		if(t==BLEND_STATE)
		{
			BlendState *bs=gEffect->DeclareBlendState(name);
			*bs= buildBlendState;
			// Set to default:
			buildBlendState=BlendState();
		}
		if(t==DEPTHSTENCIL_STATE)
		{
			DepthStencilState *ds=gEffect->DeclareDepthStencilState(name);
			*ds=buildDepthStencilState;
			// Set to default:
			buildDepthStencilState=DepthStencilState();
		}
		int true_linenumber=$7.lineno+(last_linenumber-global_linenumber);
	}
	| cslayout
	{
		currentCsLayout=$1.strs[0];
	}
	| gslayout
	{
		currentGsLayout=$1.strs[0];
	}
	| DECL_SHADER IDENTIFIER '=' shader_compile_or_instance ';'
	{
		// We here declare that a named shader should be compiled with the specified profile (e.g. GLSL 4.30)
		// and assign a variable name to the shader/profile combination. Later on, in pass definitions,
		// we can assign the shader to one or more passes.
		string shaderInstanceName		=$2.strs[0];
		ShaderInstance *cs				=gEffect->m_shaderInstances[$4.strs[0]];
		ShaderInstance *shaderInstance	=NULL;
		ShaderInstanceMap::iterator i	=gEffect->m_shaderInstances.find(shaderInstanceName);
		if(i!=gEffect->m_shaderInstances.end())
		{
			delete i->second;
			// TODO: Warn here about double-compiling a shader.
		}
		gEffect->m_shaderInstances[shaderInstanceName]=shaderInstance=cs;
	}
	| optional_uniform resource_type optional_template_type IDENTIFIER optional_register_semantic ';'
	{
		const SfxConfig *config		=gEffect->GetConfig();
		string type=$2.strs[0];
		string templ=$3.strs[0];
		string templ_type=$3.strs[1];
		string name=$4.strs[0];
		int slot=$5.num;
		
		int space=0;
		string space_num=$5.strs[2];
		if(space_num.length()>1)
		{
			space_num=space_num.substr(1,space_num.length()-1);
			space=atoi(space_num.c_str());
		}

		ShaderResourceType srt=ToShaderResourceType($2.token);
		string semantic;
		
		if(IsRW(srt))
		{
			semantic="u";
		}
		else if(srt==ShaderResourceType::TEMPLATIZED_CONSTANT_BUFFER)
		{
			semantic="b";
		}
		else
		{
			semantic="t";
		}

		// Use slots generated by SFX:
		if(config->generateSlots)
		{
			semantic+="{slot}";
		}
		// Use default slots:
		else
		{
			if(slot>=0)
				semantic+=to_string(slot);
			else
				semantic+="{slot}";
		}

		ostringstream ostr;
		ostr<<type;
		if(templ.length()>0)
			ostr<<"<"<<templ<<">";
		ostr<<" "<<name<<": register("<<semantic<<");\n";
		string original=ostr.str();
		if(srt==ShaderResourceType::TEMPLATIZED_CONSTANT_BUFFER)
		{
			DeclaredConstantBuffer *dt=gEffect->DeclareTemplatizedConstantBuffer(name, slot, space, templ_type, original);
			if (!dt)
				sfxError = true;
			else
			{
				dt->global_line_number = $2.lineno;
				dt->file_number = current_filenumber;
				dt->line_number = sfxget_lineno() + (last_linenumber - global_linenumber);
				dt->type = type;
			}
		}
		else
		{
			DeclaredTexture *dt=gEffect->DeclareTexture(name, srt, slot, space, templ_type, original);
			if (!dt)
				sfxError = true;
			else
			{
				dt->global_line_number = $2.lineno;
				dt->file_number = current_filenumber;
				dt->line_number = sfxget_lineno() + (last_linenumber - global_linenumber);
				dt->variant = false;
				dt->type = type;
				dt->layout = "";
				dt->texel_format = semantic;
			}
		}
	}
	| STRUCT IDENTIFIER struct_definition ';'
	{
		const SfxConfig *config		=gEffect->GetConfig();
		string name					=$2.strs[0];
		buildStruct.file_number		=current_filenumber;
		buildStruct.line_number		=sfxget_lineno()+(last_linenumber-global_linenumber);
		buildStruct.global_line_number	=$2.lineno;
		
		
		ostringstream ostr;
		ostr<<"struct "<<$2.strs[0]<<"\n{\n";
		for(int i=0;i<(int)buildStruct.m_structMembers.size();i++)
		{
			const StructMember &m=buildStruct.m_structMembers[i];
			ostr << m.type << " " << m.name;
			if (m.semantic.length())
				ostr << ":"<<m.semantic;
			ostr <<";\n";
		}
		ostr<<"};\n";
		
		gEffect->DeclareStruct(name,buildStruct,ostr.str());
		// Set to default:
		buildStruct					=Struct();
	}
	| CONSTANT_BUFFER IDENTIFIER optional_register_semantic shader_fx struct_definition ';' lex_passthrough
	{
		const SfxConfig *config		=gEffect->GetConfig();
		string bufferName	=$2.strs[0];
		string def			=$5.strs[0];
		string semantic		=$3.strs[0];
		int buffer_number	=$3.num;
		int sfx_linenumber	=sfxget_lineno();
		buildStruct.file_number		=current_filenumber;
		buildStruct.line_number		=$1.lineno+(last_linenumber-global_linenumber);
		buildStruct.global_line_number	=$1.lineno;

		ostringstream ostr;
		{
			WriteLineNumber(ostr,current_filename,buildStruct.line_number);
			ostr<<$1.strs[0]<<" "<<$2.strs[0]<<" "<<semantic<<" "<<$5.strs[0]<<";\n";
			WriteLineNumber(ostr,current_filename,sfxget_lineno()+(last_linenumber-global_linenumber));
		}
		gEffect->DeclareConstantBuffer(bufferName,buffer_number,buildStruct,ostr.str());
		if (!gEffect->IsConstantBufferMemberAlignmentValid(gEffect->GetDeclaration(bufferName)))
			sfxError = true;

		// Set to default:
		buildStruct					=Struct();
	}
	| shader_and_layout IDENTIFIER IDENTIFIER '(' param_declaration_list ')' optional_semantic shader_brace_block lex_passthrough
	{
		//shader void GS_SnowParticles(point particleVertexOutput inp[1], inout TriangleStream<particleGeometryOutput> SpriteStream)
		ostringstream shaderCode,inputs;
		int true_linenumber=$1.lineno+(last_linenumber-global_linenumber);
		// Add shader parameters
		GetInputs(inputs,($5.vars));
		for(vector<YYSTYPE::variable>::const_iterator it=$5.vars->begin();it!=$5.vars->end();++it)
		{
			buildFunction.parameters.push_back(*it);
		}
		delete $5.vars;
		std::string returnType=$2.strs[0];
		std::string shaderName=$3.strs[0];
		// Add definition and code
		string filename=gEffect->Filename().c_str();

		gEffect->m_cslayout[shaderName]=currentCsLayout;
		gEffect->m_gslayout[shaderName]=currentGsLayout;

		buildFunction.main_linenumber		=$2.lineno;
		buildFunction.declaration			=((returnType+" ")+ shaderName +"(")+inputs.str()+")";
		if($7.strs[0].length()>0)
		{
			buildFunction.declaration+=":";
			buildFunction.declaration+=$7.strs[0];
		}

		WriteLineNumber(shaderCode,current_filename,true_linenumber+1);
		shaderCode<<$8.strs[0];
		buildFunction.returnType	=returnType;
		buildFunction.name			=shaderName;
		buildFunction.content		=shaderCode.str();
		FinalizeFunction(buildFunction);
		gEffect->DeclareFunction(shaderName,buildFunction);
		buildFunction.clear();
		int end_linenumber			=$8.lineno+(last_linenumber-global_linenumber);
	}
	| PROGRAM lex_fx IDENTIFIER '{' prog_def '}' lex_passthrough
	{
		gEffect->m_programs[$3.strs[0]]=$5.prog;
	}
	| technique_declaration 
	{
		TechniqueGroup &group=gEffect->GetTechniqueGroup("");
		for (map<string, Technique*>::iterator it =buildGroup.m_techniques.begin(); it !=buildGroup.m_techniques.end(); ++it)
		{
			std::string techName=it->first;
			Technique *tech=it->second;
			group.m_techniques[techName]=tech;
			it->second=NULL;
		}
		buildGroup.m_techniques.clear();
	}
	| GROUP lex_fx IDENTIFIER '{' technique_list '}' lex_passthrough
	{
		currentTechniqueGroup=$3.strs[0];
		TechniqueGroup &group=gEffect->GetTechniqueGroup(currentTechniqueGroup);
		group=buildGroup;
		buildGroup.m_techniques.clear();
	}
optional_renderstate_def : '{' render_state_list '}'
	{
		$$.lineno = $1.lineno;
		$$.strs[0] = $2.strs[0];
	}
	| %empty
	{
		$$.strs[0] = "";
	}

technique_list : technique_list group_technique_declaration
	{
	}
	| group_technique_declaration
	{
	}

technique_declaration : TECHNIQUE lex_fx IDENTIFIER '{' tech_def '}' lex_passthrough
	{
		$$.strs[0]=$3.strs[0];
		$$.tech=$5.tech;
		buildGroup.m_techniques[$3.strs[0]] = $5.tech;
	}

group_technique_declaration : TECHNIQUE IDENTIFIER '{' tech_def '}'
	{
		$$.strs[0]=$2.strs[0];
		$$.tech=$4.tech;
		buildGroup.m_techniques[$2.strs[0]] = $4.tech;
	}

cslayout : '[' NUM_THREADS '(' NUM ',' NUM ',' NUM ')' ']'
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0]+$6.strs[0]+$7.strs[0]+$8.strs[0]+$9.strs[0]+$10.strs[0];
	}

gslayout : '[' MAX_VERTEX_COUNT '(' NUM ')' ']'
	{
	$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0]+$6.strs[0];
	}

optional_expression : expression
	{
		$$.strs[0]=$1.strs[0];
	}
	| %empty
	{
		$$.strs[0]="";
	}

primary_exp : IDENTIFIER
	{
		string varName=$1.strs[0];
		ConstantBuffer *cb = nullptr;
		$$.strs[0]=varName;

		if(gEffect->IsDeclared(varName))
		{
			buildFunction.declarations.insert(varName);
			buildFunction.resources.insert(varName);
		}
		else if ((cb = gEffect->GetConstantBufferForMember(varName)) != nullptr)
		{
			buildFunction.constantBuffers.insert(cb);
		}
	}
	| SATURATE
	{
		$$.token=$1.token;
		$$.strs[0]=$1.strs[0];
	}
	| constant
	{
		$$.strs[0]=$1.strs[0];
	}
	| '(' expression ')'
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

resource_type : TEMPLATIZED_CONSTANT_BUFFER
	{
		$$.strs[0]=$1.strs[0];
		$$.token=$1.token;
	}
	| RAYTRACE_ACCELERATION_STRUCT
	{
		$$.strs[0]=$1.strs[0];
		$$.token=$1.token;
	}
	| TEXTURE2D 
	{
		$$.strs[0]=$1.strs[0];
		$$.num=2;
		$$.token=$1.token;
	}
	| TEXTURE2D_ARRAY
	{
		$$.strs[0]=$1.strs[0];
		$$.num=2;
		$$.token=$1.token;
	}
	| TEXTURE1D
	{
		$$.strs[0] = $1.strs[0];
		$$.num = 2;
		$$.token = $1.token;
	}
	| TEXTURE3D_ARRAY
	{
		$$.strs[0]=$1.strs[0];
		$$.num=2;
		$$.token=$1.token;
	} 
	| TEXTURECUBE_ARRAY
	{
		$$.strs[0]=$1.strs[0];
		$$.num=2;
		$$.token=$1.token;
	} 
	| REGULARBUFFER
	{
		$$.strs[0]=$1.strs[0];
		$$.num=3;
		$$.token=$1.token;
	}
	| RW_TEXTURE1D
	{
		$$.strs[0]=$1.strs[0];
		$$.num=2;
		$$.token=$1.token;
	}
	| RW_TEXTURE2D
	{
		$$.strs[0]=$1.strs[0];
		$$.num=2;
		$$.token=$1.token;
	}
	| RW_TEXTURE2D_ARRAY
	{
		$$.strs[0]=$1.strs[0];
		$$.num=2;
		$$.token=$1.token;
	}
	| RW_TEXTURE3D
	{
		$$.strs[0]=$1.strs[0];
		$$.num=3;
		$$.token=$1.token;
	}
	| RW_TEXTURE3D_ARRAY
	{
		$$.strs[0]=$1.strs[0];
		$$.num=3;
		$$.token=$1.token;
	}
	| RW_REGULARBUFFER
	{
		$$.strs[0]=$1.strs[0];
		$$.num=3;
		$$.token=$1.token;
	}
	| STRUCTUREDBUFFER
	{
		$$.strs[0]=$1.strs[0];
		$$.num=3;
		$$.token=$1.token;
	}
	| RW_STRUCTUREDBUFFER
	{
		$$.strs[0]=$1.strs[0];
		$$.num=3;
		$$.token=$1.token;
	}
	| TEXTURE2DMS
	{
		$$.strs[0]=$1.strs[0];
		$$.num=2;
		$$.token=$1.token;
	}
	| TEXTURECUBE
	{
		$$.strs[0]=$1.strs[0];
		$$.num=2;
			$$.token=$1.token;
	}
	| TEXTURE3D
	{
		$$.strs[0]=$1.strs[0];
		$$.num=3;
		$$.token=$1.token;
	}

constant : int_or_float
	{
		$$.strs[0] = $1.strs[0];
		$$.num = $1.num;
	}
	| '(' int_or_float ')'
	{
		$$.strs[0] = $2.strs[0];
		$$.num = $2.num;
	}

int_or_float : NUM
	{
		$$.strs[0]=$1.strs[0];
	}
	| P_FLOAT
	{
		$$.strs[0]=$1.strs[0];
	}
number_exp : additive_num
	{
		$$.strs[0]=$1.strs[0];
	}
	| '(' additive_num ')'
	{
		$$.strs[0] = $2.strs[0];
		$$.num = $2.num;
	}

additive_num : mult_num
	{
		$$.strs[0]=$1.strs[0];
	}
	| additive_num '+' mult_num
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}
	| additive_num '-' mult_num
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

mult_num : unary_num
	{
		$$.strs[0]=$1.strs[0];
	}
	| mult_num '*' unary_num
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}
	| mult_num '/' unary_num
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}
	| mult_num '%' unary_num
	{
		const SfxConfig* sfxConfig	= gEffect->GetConfig();
		if(sfxConfig->supportsPercentOperator)
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		}
		else
		{
			$$.strs[0]=(string("typed_mod(")+$1.strs[0]+",")+$3.strs[0]+")";
			CallingFunction("typed_mod");

		}
	}

unary_num : number
	{
		$$.strs[0]=$1.strs[0];
	}
	| unary_operator unary_num
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0];
	}

number : NUM
	{
		$$.strs[0]=$1.strs[0];
		$$.num=$1.num;
	}

optional_template_type : '<' optional_unorm_snorm IDENTIFIER '>'
	{
		$$.strs[0]=($2.strs[0]+" ")+$3.strs[0];
		$$.strs[1]=$3.strs[0];
	}
	| %empty
	{
		$$.strs[0]="";
		$$.strs[1]="";
	}


optional_unorm_snorm: UNORM
	{
		$$.strs[0]=$1.strs[0];
	} | SNORM
	{
		$$.strs[0]=$1.strs[0];
	} | %empty
	{
		$$.strs[0]="";
	}

optional_register_semantic : ':' REGISTER '(' IDENTIFIER optional_additional_identifier ')'
	{
		$$.strs[0]=string(": register(")+$4.strs[0]+$5.strs[0]+")";
		$$.strs[1]=$4.strs[0];
		$$.strs[2]=$4.strs[1];
		string idnum=$4.strs[0];
		if(idnum.length()>1)
		{
			idnum=idnum.substr(1,idnum.length()-1);
			$$.num=atoi(idnum.c_str());
		}
		else
		{
			$$.num=-1;
		}
	}
	| %empty
	{
		$$.strs[0]="";
		$$.strs[1]="";
		$$.num=-1;
	}

shader_brace_block : '{' statement_list '}'
	{
		string content = $2.strs[0];
		$$.strs[0]=content;
		$$.lineno=$3.lineno;
	}

statement_list : statement_list statement
	{
		string statement_list=$1.strs[0] + "\n";
		string statement = $2.strs[0];
		if(insert_line_statement>0)
		{
			statement=CreateLineStatement($2.lineno)+statement;
		}
		statement_list += statement;
		$$.strs[0]	=statement_list;
		$$.strs[1]	=$1.strs[1]+$2.strs[1];
	}
	| statement
	{
		string statement=$1.strs[0];
		if(insert_line_statement>0)
		{
			statement=CreateLineStatement($1.lineno)+statement;
		}
		insert_line_statement=0;
		$$.strs[0]	=statement;
		$$.strs[1]	=$1.strs[1];
	}
	| %empty
	{
		$$.strs[0]	="";
		$$.strs[1]	="";
	}

initializer : assignment_exp
	{
		string assignment_exp = $1.strs[0];
		$$.strs[0]=assignment_exp;
	}
	| '{' initializer_list '}'
	{
		vector<sfxstype> &children = $$.children;
		children = $2.children;
		string initlist = $1.strs[0] + $2.strs[0] + $3.strs[0];
		$$.strs[0] = initlist;
	}
	| '{' initializer_list ',' '}'
	{
		vector<sfxstype> &children = $$.children;
		children = $2.children;
		string initlist = $1.strs[0] + $2.strs[0] + $3.strs[0] + $4.strs[0];
		$$.strs[0] = initlist;
	}

line_statement_in_shader : LINE NUM QUOTED_STRING EOL
	{
		last_linenumber		=$2.num;
		current_filenumber	=$3.num;
		global_linenumber	=$1.lineno+1;
		$$.strs[0]			=$1.strs[0]+" ";
		$$.strs[0]			+=$2.strs[0]+" ";
		$$.strs[0]			+=$3.strs[0];
		$$.strs[0]			+='\n';
	}

initializer_list : initializer
	{
		vector<sfxstype> &children = $$.children;
		children.clear();
		children.push_back($1);
		$$.strs[0]=$1.strs[0];
	}
	| initializer_list ',' initializer
	{
		vector<sfxstype> &children = $$.children;
		children = $1.children;
		children.push_back($3);
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

// multiple statements in braces
compound_statement : '{' statement_list '}'
	{
		string statement_list=$2.strs[0];
		$$.strs[0]=string("\n{\n")+statement_list+"\n}\n";
	}

declaration_or_function : decl_specs decl_list_or_fn
	{
		if ($2.num == 0)
		{
			string type_spec = $1.strs[0];
			Variable variable;
			variable.original = type_spec + " ";
			string init_declarator_list = $2.strs[0];
			if (type_spec == "float")
				type_spec = "";
			stringReplaceAll(init_declarator_list, "%type%", type_spec);
			stringReplaceAll(init_declarator_list, type_spec + type_spec, type_spec);
			variable.init_declarator_list = init_declarator_list;
			variable.original += init_declarator_list;
			variable.name=$2.strs[1];
			variable.structureType= $1.strs[1];
			gEffect->DeclareVariable(&variable);
		}
		else
		{
			string functionName				=$2.strs[0];
			string inputs					=$2.strs[2];
			buildFunction.returnType		=$1.strs[0];
			buildFunction.main_linenumber	=$1.lineno;
			buildFunction.local_linenumber	=$1.lineno + (last_linenumber - global_linenumber);
			buildFunction.declaration		=(($1.strs[0] + " ") + $2.strs[0] + "(") + inputs + ")";
			FinalizeFunction(buildFunction);
			buildFunction.name				= functionName;
			Function *f						= gEffect->DeclareFunction(functionName, buildFunction);
			buildFunction.clear();
		}
	}

declaration : decl_specs init_declarator_list
	{
		$$.strs[0] =($1.strs[0] +" ") +$2.strs[0];
		sfxstype::variable var;
		var.type=$1.strs[0];
		var.identifier=$2.strs[2];
		buildFunction.locals.push_back(var);
		$$.strs[1]=$2.strs[0];
	}

decl_list_or_fn : init_declarator_list ';'
	{
		$$.strs[0] = $1.strs[0] + ";";
		$$.strs[1]= $1.strs[1];
		$$.num = 0;
	}
	| function_def
	{
		$$.strs[0] = $1.strs[0];
		$$.strs[1]	=$1.strs[1];
		$$.strs[2] = $1.strs[2];
		$$.num = 1;
	}

function_def : IDENTIFIER p_dec_list shader_brace_block
	{
		string functionName			=$1.strs[0];
		buildFunction.content		=$3.strs[0];
		buildFunction.filename		=current_filename;
		string inputs				=$2.strs[0];
		buildFunction.parameters	=*$2.vars;
		delete $2.vars;
		$$.strs[0]					=functionName;
		$$.strs[1]					= functionName;
		$$.strs[2]					=inputs;
	}

p_dec_list : '(' param_declaration_list ')'
	{
		ostringstream inputs;
		GetInputs(inputs,($2.vars));
		$$.strs[0]=inputs.str();
		$$.vars=$2.vars;
	}

init_declarator_list : init_declarator
	{
		$$.strs[0]=$1.strs[0];
		$$.strs[1]=$1.strs[1];
		$$.strs[2]=$1.strs[2];
	}
	| init_declarator_list ',' init_declarator
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		$$.strs[1] =( $1.strs[1]+',')+ $3.strs[1];
		$$.strs[2]=$1.strs[2];
	}

init_declarator : declarator
	{
		$$.strs[0] = $1.strs[0];
		$$.strs[1] = $1.strs[1];
		$$.strs[2] = $1.strs[0];
	}
	| declarator '=' initializer
	{
		// An expression of the form vec2 c=....;
		// Pass-through normally, but most GLSL compilers cannot handle array initializers.
		string declarator	=$1.strs[0];
		string initializer	=$3.strs[0];
		$$.strs[0] = $1.strs[0] + $2.strs[0] + initializer;
		$$.strs[1] = $1.strs[1];
		$$.strs[2] = declarator;
	}

declarator : IDENTIFIER
	{
		$$.strs[0]=$1.strs[0];
		$$.strs[1]=$1.strs[0];
	}
	| '(' declarator ')'
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		$$.strs[1] = $1.strs[1];
	}
	| declarator '[' number_exp ']'
	{
		$$.num=$3.num;
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0];
		$$.strs[1]=$1.strs[0];
		$$.strs[2]=$3.strs[0];
	}
	| declarator '[' ']'
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		$$.strs[1]=$1.strs[0];
	}

expression : assignment_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| expression ',' assignment_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

assignment_exp : conditional_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| unary_exp assignment_operator assignment_exp
	{
		string unary_exp			=$1.strs[0];
		string assignment_operator	=$2.strs[0];
		string assignment_exp		=$3.strs[0];
		string varName				=$1.strs[1];
		string index				=$1.strs[3];
		// Is it actually a texture we're indexing?
		ShaderResourceType resourceType		=GetShaderResourceType(buildFunction,varName);
		if(resourceType==ShaderResourceType::UNKNOWN||!IsRW(resourceType))
		{
			$$.strs[0]=unary_exp+assignment_operator+assignment_exp;
		}
		else
		{
			ostringstream str;
			if($2.token=='=')
			{
				const SfxConfig *config		=gEffect->GetConfig();
				// Only apply this to textures not to SSBOs
				if(	config->storeSyntax.length() > 0 && 
					resourceType != ShaderResourceType::STRUCTURED_BUFFER &&  
					resourceType != ShaderResourceType::RW_STRUCTURED_BUFFER
					&&resourceType!=ShaderResourceType::UNKNOWN)
				{
					string s=config->storeSyntax;
					auto toStoreDec = gEffect->declarations.find(varName);
					if(toStoreDec != gEffect->declarations.end())
					{
						if(toStoreDec->second->structureType == "vec4" || toStoreDec->second->structureType == "float4")
						{
							find_and_replace(s,"{cast}","vec4");
						}
						else if(toStoreDec->second->structureType == "char4")
						{
							find_and_replace(s,"{cast}","vec4");
						}
						else if(toStoreDec->second->structureType == "uchar4")
						{
							find_and_replace(s,"{cast}","vec4");
						}
						else if(toStoreDec->second->structureType == "ivec4")
						{
							find_and_replace(s,"{cast}","ivec4");
						}
						else if(toStoreDec->second->structureType == "uint")
						{
							find_and_replace(s,"{cast}","uvec4");
						}
						else if(toStoreDec->second->structureType == "float")
						{
							find_and_replace(s,"{cast}","vec4");
						}
						else if(toStoreDec->second->structureType == "half4")
						{
							find_and_replace(s,"{cast}","vec4");
						}
						else if (toStoreDec->second->structureType == "f16vec4")
						{
							find_and_replace(s, "{cast}", "f16vec4");
						}
						else
						{
							// God almighty.
							//find_and_replace(s,"{cast}","nullcast");
							errSem(string("Unsupported structure type for image store: ") + toStoreDec->second->structureType);
						}
					}							   
					else
					{
						find_and_replace(s,"{cast}","");
					}
					find_and_replace(s,"{varName}",varName);
					find_and_replace(s,"{index}",index);
					find_and_replace(s,"{tex_dimension}",ToString(GetTextureDimension(resourceType)));
					find_and_replace(s,"{assignment_exp}",assignment_exp);
					str<<s;
				}
				else
				{
					str<<unary_exp<<assignment_operator<<assignment_exp;
				}
			}
			else
				errSem(string("Unsupported operator for image store: ")+assignment_operator);
			$$.strs[0]=str.str();
		}
	}

conditional_exp : logical_or_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| logical_or_exp '?' expression ':' conditional_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0];
	}
	
logical_or_exp : logical_and_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| logical_or_exp OR logical_and_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

logical_and_exp : inclusive_or_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| logical_and_exp AND inclusive_or_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

inclusive_or_exp : exclusive_or_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| inclusive_or_exp '|' exclusive_or_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

exclusive_or_exp : and_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| exclusive_or_exp '^' and_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

and_exp : equality_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| and_exp '&' equality_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

equality_exp : relational_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| equality_exp EQ_EQ relational_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}
	| equality_exp NOT_EQ relational_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

relational_exp : shift_expression
	{
		$$.strs[0]=$1.strs[0];
	}
	| relational_exp '<' shift_expression
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}
	| relational_exp '>' shift_expression
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}
	| relational_exp LESS_EQ shift_expression
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}
	| relational_exp GRTR_EQ shift_expression
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

shift_expression : additive_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| shift_expression LEFT_SHIFT additive_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}
	| shift_expression RIGHT_SHIFT additive_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

additive_exp : mult_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| additive_exp '+' mult_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}
	| additive_exp '-' mult_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

mult_exp : cast_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| mult_exp '*' cast_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}
	| mult_exp '/' cast_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}
	| mult_exp '%' cast_exp
	{
		const SfxConfig* sfxConfig	= gEffect->GetConfig();
		if(sfxConfig->supportsPercentOperator)
		{
			$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		}
		else
		{
			$$.strs[0]=(string("typed_mod(")+$1.strs[0]+",")+$3.strs[0]+")";
			CallingFunction("typed_mod");
		}
	}

cast_exp : unary_exp
	{
		$$.strs[0]=$1.strs[0];
	}
	| cast unary_exp
	{
		string typestr=$1.strs[1];
		string conv=$2.strs[0];
		// convert old-style cast to new style.
		$$.strs[0] = ((typestr +"(")+conv)+")";
	}

cast : '(' IDENTIFIER ')'
	{
		// TODO: This causes spurious compile errors due to identifying variables where there should here by typenames.
		$$.strs[0] = $1.strs[0] + $2.strs[0] + $3.strs[0];
	}

unary_exp : postfix_exp
	{
		$$.strs[0]=$1.strs[0];
		$$.strs[1]=$1.strs[1];
		$$.strs[2]=$1.strs[2];
		$$.strs[3]=$1.strs[3];
	}
	| PLUS_PLUS unary_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0];
	}
	| MINUS_MINUS unary_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0];
	}
	| unary_operator cast_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0];
	}

unary_operator : '&' | '*' | '+' | '-' | '~' | '!'
	{
		$$.strs[0]=$1.strs[0];
	}
postfix_indexed : postfix_exp '[' expression ']'
	{
		string varName	= $1.strs[0];
		string index	= $3.strs[0];
		$$.strs[1]		= varName;
		$$.strs[3]		= index;
		$$.strs[2]		= $1.strs[2];		

		// Check if it is a texture
		ShaderResourceType resourceType	= GetShaderResourceType(buildFunction,varName);
		if(resourceType == ShaderResourceType::UNKNOWN)
		{
			$$.strs[0]=varName+$2.strs[0]+index+$4.strs[0];
		}
		else
		{
			auto config = gEffect->GetConfig();
			ostringstream str;
			if(config->combineTexturesSamplers)
			{
				// Here we WRITE to a structured buffer: 
				if((resourceType & ShaderResourceType::STRUCTURED_BUFFER) == ShaderResourceType::STRUCTURED_BUFFER)
				{
					str << varName << "[" << index << "]";
				}
				// And here we LOAD from something else ? Its probably a texture!
				else
				{
					str << GetLoadExpr(varName,"0",index,resourceType,false);
					// If and only its a RW texture (load operation), we insert it into the list
					if(str.str().find("imageLoad") != std::string::npos)
					{
						buildFunction.rwTexturesLoaded.insert(varName);
					}
				}
			}
			else
			{
				str << varName << "[" << index << "]";
			}
			buildFunction.declarations.insert(varName);
			buildFunction.resources.insert(varName);
			$$.strs[0]=str.str();
		}
	}
postfix_exp : primary_exp
	{
		$$.token=$1.token;
		string varName = $1.strs[0];
		$$.strs[0]= varName;
		$$.strs[2]= varName;			//Command
	}
	| postfix_indexed
	{
		$$.strs[0]=$1.strs[0];
		$$.strs[1]=$1.strs[1];
		$$.strs[2]=$1.strs[2];
		$$.strs[3]=$1.strs[3];
	}
	| get_dims_exp '(' assignment_exp ',' assignment_exp ')'
	{
		string textureName	=$1.strs[1];
		string x			=$3.strs[0];
		string y			=$5.strs[0];
		
		$$.strs[0]=GetSizeFunction(textureName, x, y,"");
		buildFunction.declarations.insert(textureName);
		buildFunction.resources.insert(textureName);
	}
	| get_dims_exp '(' assignment_exp ',' assignment_exp ',' assignment_exp ')'
	{
		string textureName	=$1.strs[1];
		string x			=$3.strs[0];
		string y			=$5.strs[0];
		string z			=$7.strs[0];
		$$.strs[0]			=GetSizeFunction( textureName, x, y,z);
		buildFunction.declarations.insert(textureName);
		buildFunction.resources.insert(textureName);
	}
	| tex_load_exp '(' argument_exp_list ')'
	{
		const SfxConfig* config	= gEffect->GetConfig();
		string textureName		= $1.strs[1];
		string command			= $1.strs[2];
		string params			= $3.strs[0];
		string pos,msaa_index;
		ostringstream full_expr;
		if($3.vars)
		{
			auto vars=*($3.vars);
			delete $3.vars;
			pos				=vars[0].identifier;
			if(vars.size()>1)
				msaa_index=vars[1].identifier;
		}
		if(config->loadSyntax.size() > 0)
		{
			ShaderResourceType resourceType	= GetShaderResourceType(buildFunction,textureName);
			if(resourceType!=ShaderResourceType::UNKNOWN)
			{
				if(pos.size() > 0 && msaa_index.size() > 0)
				{
					full_expr << GetLoadExprMSAA(textureName,command,params,resourceType,pos,msaa_index);
				}
				else
				{
					full_expr << GetLoadExpr(textureName,command,params,resourceType);
				}
			}
			else
			{
				full_expr<<"{load_expr "<<textureName<<" "<<command<<" "<<params<<" "<<pos<<" "<<msaa_index<<"}";
			}
		}
		else
		{
			full_expr << textureName << "." << command << "(" << params <<")";
		}
		$$.strs[0] = full_expr.str();
		buildFunction.rwTexturesLoaded.insert(textureName);
		buildFunction.declarations.insert(textureName);
		buildFunction.resources.insert(textureName);
	}
	| sampling_exp '(' assignment_exp ',' argument_exp_list ')'
	{
		string textureName		=$1.strs[1];
		string command			=$1.strs[2];
		string samplerStateName	=$3.strs[0];
		string otherParams		=$5.strs[0];
		vector<sfxstype::variable>*	params=$5.vars;
	
		ostringstream full_expr;
		const SfxConfig *config	= gEffect->GetConfig();
		
		// Special syntax used to sample:
		//  e.g noise3D.Sample(clampSampler,uv); -> texture(sampler3D(noise3D | clampSampler),uv);
		//  We must choose the proper:			  {command}({samplerType}(tex|sampler),params);
		if( config->samplingSyntax.length() > 0)
		{
			ShaderResourceType type = GetShaderResourceType(buildFunction, textureName);
			string samplerType	  = GetSamplerConstructor(type,textureName,&buildFunction);
			string cmd			  = config->samplingSyntax;
			find_and_replace(cmd,"{command}",command);
			find_and_replace(cmd,"{samplerType}",samplerType);
			string combTexSamp = "";
			if(config->combineTexturesSamplers )
			{
				if(config->combineInShader)
				{
					combTexSamp = textureName + ", " + samplerStateName;
				}
				else
				{
					// combTexSamp = textureName + "_xfs_" + samplerStateName;
					combTexSamp = textureName + "[" + samplerStateName + "]";
				}
			}
			const SfxConfig *config	= gEffect->GetConfig();
			find_and_replace(cmd,"{textureSampler}",combTexSamp);
			if(!config->reverseTexCoordY||!params||params->size()<1)
				find_and_replace(cmd,"{otherParams}",otherParams);
			else
			{
				ostringstream otherParams;
				std::string firstParam=(*params)[0].identifier;
				otherParams<<"reverse_y_coord("<<firstParam<<")";
				for(int i=1;i<params->size();i++)
					otherParams<<","<<(*params)[i].identifier;
				find_and_replace(cmd,"{otherParams}",otherParams.str());
				const std::map<std::string,std::vector<Function*> > &functions=gEffect->GetFunctions();
				auto j=functions.find("reverse_y_coord");
				for(auto u=j->second.begin();u!=j->second.end();u++)
					buildFunction.functionsCalled.insert(*u);
			}
			full_expr << cmd;	
		}
		else
		{
			full_expr << textureName << "." << command << "(" << samplerStateName << "," << otherParams << ")";
		}
		buildFunction.declarations.insert(textureName);
		buildFunction.resources.insert(textureName);
		buildFunction.resources.insert(samplerStateName);						
		$$.strs[0] = full_expr.str();
	}
	| postfix_exp '(' argument_exp_list ')'
	{
		string expr1=$1.strs[0];
		string expr2=$2.strs[0];
		string params;
		auto vars			=*($3.vars);
		delete $3.vars;
		string expr4		=$4.strs[0];
		const SfxConfig *config	= gEffect->GetConfig();
		// ok this could be a function call.(((std::basic_string<char,std::char_traits<char>,std::allocator<char> >*)(&(command)))->_Bx._Buf)[0]=='d'
		string command		=$1.strs[2];
		const std::map<std::string,std::vector<Function*> > &functions=gEffect->GetFunctions();
		auto j=functions.find(command);
		auto dec = gEffect->GetDeclarations();
		if(j==functions.end())
		{
			params=$3.strs[0];
		}
		else
		{
			// Right, it's a function call.
			int num=0;
			for(auto u=j->second.begin();u!=j->second.end();u++)
			{
				if((*u)->parameters.size()<vars.size())
					continue;
				// default parameters?
				if (vars.size() < (*u)->min_parameters)
					continue;
				buildFunction.functionsCalled.insert(*u);
				num++;
			}
			for(auto u=j->second.begin();u!=j->second.end();u++)
			{
				if ((*u)->parameters.size()<vars.size())
					continue;
				if (vars.size() < (*u)->min_parameters)
					continue;
				Function &f=**u;
				// If it's a known function, there may need to be a mapping from the texture and sampler parameters.
				// We figure out this mapping by looking at the vars list of the function we're calling.
				// this is the unmodified list, so it corresponds to the call we're making.
				for(int index=0;index<f.parameters.size();index++)
				{
					const sfxstype::variable &param	=f.parameters[index];
					string declared_name			=param.identifier;
					// That's how the parameter was declared. Is it in the original list?
					if(index>=0&&index<vars.size())
					{
						const sfxstype::variable &p=vars[index];
						if(params.size())
							params+=",";
						// Standard behaviour (HLSL, PSSL & GLSL(Switch))
						if(!config->combineTexturesSamplers || (config->combineTexturesSamplers && config->combineInShader))
						{
							// Nothing to do here...
							params += p.identifier;
						}
						string root_identifier=p.identifier;
						size_t first_dot=root_identifier.find('.');
						if(first_dot<root_identifier.length())
							root_identifier=root_identifier.substr(0,first_dot);
						// This is how OUR function knows this parameter.
						buildFunction.declarations.insert(root_identifier);
						buildFunction.resources.insert(root_identifier);
						const Declaration *d=gEffect->GetDeclaration(p.identifier);
					if(d && d->declarationType == DeclarationType::SAMPLER)
						{
							buildFunction.resources.insert(p.identifier);
							if(config->combineTexturesSamplers && !config->combineInShader)
							{
								// We pass the index of the array:  uint64 textureXXX[kMaxTextures]; 
								//								  GetCloudIllum(vec3 pos, int cloudSampler);
								//								  texture(sampler2D(textureXXX[cloudSampler]),pos);
								auto sampDec = (SamplerState*)d;
								params += std::string("1 + ")  + std::to_string(sampDec->register_number);
							}
						}
						else if(d && d->declarationType == DeclarationType::TEXTURE)
						{
							if(config->combineTexturesSamplers && !config->combineInShader)
							{
								params += p.identifier;
							}
						}
						else
						{
							if(config->combineTexturesSamplers && !config->combineInShader)
							{
								params += p.identifier;
							}
						}
					if(param.shaderResourceType!=ShaderResourceType::UNKNOWN)
						{
							buildFunction.resources.insert(p.identifier);
						}
					}
					else if (index >= 0)
					{
					}
					else // could be a textureSampler...
					{
						if(params.size())
							params+=",";
						params+=declared_name;
					}
				}
				break;
			}
			if(num==0)
			{
				errSem(string("No matching function definition found for ")+command);
				break;
			}
		}
		$$.strs[0]=expr1+expr2+params+expr4;
	}
	| postfix_exp '(' ')'
	{
		// ok this could be a function call.
		string command=$1.strs[2];
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}
	| postfix_exp '.' IDENTIFIER
	{
		string expr1=$1.strs[0];
		if(gEffect->GetDeclaration(expr1)!=nullptr)
			buildFunction.resources.insert(expr1);
		string expr3=$3.strs[0];
		$$.strs[2]=expr3;			//Command
		$$.strs[0]=expr1+$2.strs[0]+expr3;
	}
	| postfix_exp PLUS_PLUS
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0];
	}
	| postfix_exp MINUS_MINUS
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0];
	}
assignment_operator : '='
	{
		$$.strs[0]=$1.strs[0];
		$$.token=$1.token;
	}
	| TIMES_EQUALS
	| OVER_EQUALS
	| PERCENT_EQUALS
	| PLUS_EQUALS
	| MINUS_EQUALS
	| LEFT_SHIFT_EQUALS
	| RIGHT_SHIFT_EQUALS
	| AND_EQUALS
	| XOR_EQUALS
	| OR_EQUALS
	{
		$$.strs[0]=$1.strs[0];
		$$.token=$1.token;
	}

sampling_command : SAMPLE
	{
		$$.strs[0]="Sample";
	}
	| SAMPLE_LOD
	{
		$$.strs[0]="SampleLevel";
	}
tex_load_command : LOAD
	{
		$$.strs[0]="Load";
	}
decl_specs : IDENTIFIER
	{
		$$.strs[0] = $1.strs[0];
		$$.strs[1] = $1.strs[0];
	}
	| type_qualifier type_spec
	{
		$$.strs[0] = ($1.strs[0]+" ")+$2.strs[0];
		$$.strs[1] = $2.strs[0];
	}

type_spec : IDENTIFIER
	{
		$$.strs[0] = $1.strs[0];
	}

tex_load_exp : postfix_exp '.' tex_load_command
	{
		string texture=$1.strs[0];
		string command=$3.strs[0];
		$$.strs[0]="";
		// Put the thing we're sampling into strs[1]
		$$.strs[1]=texture;
		// We put the command into strs[2]
		$$.strs[2]=command;
	}
sampling_exp :	postfix_exp '.' sampling_command
	{
		string texture=$1.strs[0];
		string command=$3.strs[0];
		$$.strs[0]="";
		// Put the thing we're sampling into strs[1]
		$$.strs[1]=texture;
		// We put the command into strs[2]
		$$.strs[2]=command;
	}
get_dims_exp : postfix_exp '.' GET_DIMS
	{
		string texture=$1.strs[0];
		string command=$3.strs[0];
		$$.strs[0]=texture+$2.strs[0]+command;
		// Put the thing we're sampling into strs[1]
		$$.strs[1]=texture;
		// We put the command into strs[2]
		$$.strs[2]=command;
	}			
argument_exp_list : argument_exp_list ',' assignment_exp
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		$$.vars=$1.vars;
		YYSTYPE::variable var;
		var.identifier	=$3.strs[0];
		$$.vars->push_back(var);
	}
	| assignment_exp
	{
		$$.strs[0]=$1.strs[0];
		$$.vars = new vector<YYSTYPE::variable>;
		YYSTYPE::variable var;
		var.identifier	=$1.strs[0];
		$$.vars->push_back(var);
	}


for_init_statement : expression
	{
		$$.strs[0]=$1.strs[0];
	}
	| declaration
	{
		$$.strs[0]=$1.strs[0];
	}
	| %empty
	{}
statement : COMMENT
	{
		$$.strs[0]=$1.strs[0];
		$$.strs[1]="";
	}
	| WHITESPACE
	{
		$$.strs[0]=$1.strs[0];
	}
	 | SHADER_LINE
	 {
		$$.strs[0]=$1.strs[0];
	 }
	| expression ';'
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0];
		$$.lineno=$1.lineno;
		$$.strs[1]="";
	}
	| ';'
	{
		$$.strs[0]=$1.strs[0];
		$$.strs[1]="";
	}
	| declaration ';'
	{
		string declaration=$1.strs[0]+$2.strs[0];
		$$.strs[0]=declaration;
		$$.strs[1]="";
	}
	| compound_statement
	{
		string compound_statement=$1.strs[0];
		$$.strs[0]=compound_statement;
		$$.strs[1]="";
	}
	| IF '(' expression ')' statement
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0];
		$$.strs[1]="";
	}
	| IF '(' expression ')' statement ELSE statement
	{
		string s1=$1.strs[0];
		string s2=$2.strs[0];
		string s3=$3.strs[0];
		string s4=$4.strs[0];
		string s5=$5.strs[0];
		string s6=$6.strs[0];
		string s7=$7.strs[0];
		$$.strs[0]=(s1+s2+s3+s4+s5+s6+"\n")+s7;
		$$.strs[1]="";
	}
	| WHILE '(' expression ')' statement
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0];
		$$.strs[1]="";
	}
	| DO statement WHILE '(' expression ')' ';'
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0]+$6.strs[0]+$7.strs[0];
		$$.strs[1]="";
	}
	| FOR '(' for_init_statement ';' optional_expression ';' optional_expression ')' statement
	{
		string statement=$9.strs[0];
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0]+$6.strs[0]+$7.strs[0]+$8.strs[0]+statement;
		$$.strs[1]="";
	}
	| SWITCH '(' expression ')' '{' switch_cases '}'
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0]+$4.strs[0]+$5.strs[0]+$6.strs[0]+$7.strs[0];
	}
	| GOTO IDENTIFIER ';'
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
		$$.strs[1]="";
	}
	| CONTINUE ';'
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0];
		$$.strs[1]="";
	}
	| BREAK ';'
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0];
		$$.strs[1]="";
	}
	| RETURN optional_expression ';'
	{
		string optional_expression=$2.strs[0];
		if(read_shader&&optional_expression.length()>0)
		{
			$$.strs[0] = ($1.strs[0] + " ") + optional_expression + $3.strs[0];
			$$.strs[1]=optional_expression;
		}
		else
		{
			$$.strs[0]=($1.strs[0]+" ")+optional_expression+$3.strs[0];
			$$.strs[1]=optional_expression;
		}
		$$.lineno=$1.lineno;
	}
	| line_statement_in_shader
	{
		$$.strs[0]=$1.strs[0];
		$$.strs[1]="";
		$$.lineno=$1.lineno;
	}


line_statement : LINE lex_fx NUM number_or_filename lex_passthrough
	{
		last_linenumber=$3.num;
		current_filenumber=$4.num;
		current_filename=$4.strs[0];
		if(current_filenumber<0)
			current_filenumber=gEffect->GetFilenumber(current_filename);
		else if(current_filename=="")
			current_filename=gEffect->GetFilename(current_filenumber);
			// Global linenumber means the line in the preprocessed file
			// that this #line directive refers to, i.e. the NEXT line
			// after the #line directive.
		global_linenumber=$1.lineno+1;
	}

ignore_line_statement: LINE NUM number_or_filename
	{
		last_linenumber=$2.num;
		current_filenumber=$3.num;
		current_filename=$3.strs[0];
		if(current_filenumber<0)
			current_filenumber=gEffect->GetFilenumber(current_filename);
		else if(current_filename=="")
			current_filename=gEffect->GetFilename(current_filenumber);
		global_linenumber=$1.lineno;
	}

shader_and_layout : SHADER shader_fx 
	{
		string s1=$1.strs[0];
		$$.strs[0]=s1;
	};
	
lex_fx : %empty
	{ 
		//Switch lex to fx scanning
		read_shader=false;
		read_function = false;
		gLexPassthrough=false;
	}

shader_fx : %empty
	{
		read_shader=true;
		read_function = false;
		gLexPassthrough=false;
	}

number_or_filename : NUM
	{
		 $$.num=$1.num;
		 $$.strs[0]="";
	}
	| QUOTED_STRING
	{
		 // Strip the quotes. I think we are guaranteed that they will be the 0 and length-1 characters in the string.
		 string str=$1.strs[0];
		 str=str.substr(1,str.length()-2);
		 $$.strs[0]=str;
		 $$.num=-1;
	};

lex_passthrough : %empty
	{ 
		//Switch lex to passthrough mode
		gLexPassthrough=false;
	};

read_block : %empty
	{ 
		//Read next block
		$$.strs[0]= sfxreadblock('{', '}');
		$$.lineno= sfxget_lineno();
	}

struct_definition : '{' struct_member_list '}'
	{
		$$.strs[0]="{\n";
		$$.strs[0]+=($2.strs[0]+"\n}\n");
	}

switch_cases : switch_cases switch_case
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0];
	} 
	| switch_case
	{
		$$.strs[0]=$1.strs[0];
	}

switch_case : CASE expression ':' statement_list
	{
		$$.strs[0]=($1.strs[0]+" ")+$2.strs[0]+$3.strs[0]+$4.strs[0];
	} 
	| DEFAULT ':' statement_list
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0]+$3.strs[0];
	}

struct_member_list : struct_member_list struct_element
	{
		string list			=$1.strs[0];
		string new_member	=$2.strs[0];
		$$.strs[0]=(list+"\n")+new_member;
	}
	| struct_element
	{
		string member=$1.strs[0];
		$$.strs[0]=member;
	}
struct_element : struct_memb
	{
		string str=$1.strs[0];
		$$.strs[0]	=str;
	}
	| ignore_line_statement
	{
		$$.lineno = $1.lineno;
		$$.num = -1;
		$$.strs[0]	="";
	}
	| COMMENT
	{
		Skip();
	}
	| WHITESPACE
	{
		Skip();
	}
optional_uniform : UNIFORM
	{
		$$.strs[0]="uniform";
	}
	| UNIFORM FLAT
	{
		$$.strs[0] = "uniform flat";
	}
	| FLAT
	{
		$$.strs[0] = "flat";
	}
	| %empty
	{
		$$.strs[0]="";
	}
struct_memb : optional_uniform IDENTIFIER IDENTIFIER opt_sq optional_semantic ';'
	{
		$$.lineno		=$4.lineno;
		string unif		=$1.strs[0];
		string type		=$2.strs[0];
		string name		=$3.strs[0];
		string sq		=$4.strs[0];
		string sem		=$5.strs[0];
		StructMember s;
		s.type		=type;
		s.semantic	=sem;
		s.name		=name+sq;
		buildStruct.m_structMembers.push_back(s);
		$$.strs[0]=(unif.length()?(unif+" "):"");
		$$.strs[0]+=(type+" ")+name;
		$$.strs[0]+=sq;
		$$.strs[0]+=sem.length()?(string(": ")+sem):"";
		$$.strs[0]+=";";
	}

opt_sq : '[' opt_num ']'
	{
		$$.strs[0]=(string("[")+$2.strs[0])+"]";
		$$.num=$2.num;
	}
	| %empty
	{
		$$.strs[0]="";
		$$.num=0;
	};
opt_num : number_exp
	{
		$$.strs[0]=$1.strs[0];
		$$.num=$1.num;
	}
	| %empty
	{
		$$.strs[0]="";
		$$.num=0;
	}
	// NOTE: Need comprehensive arithemetic for declaration integers
	| NUM '*' NUM
	{
		$$.num=$1.num*$3.num;
		$$.strs[0]=stringFormat("%d",$$.num);
	}

optional_additional_identifier : ',' IDENTIFIER
	{
		$$.strs[0]=$1.strs[0]+$2.strs[0];
	}
	| %empty
	{
		$$.strs[0]="";
	}

param_declaration_list : param_declaration_list ',' param_declaration
	{
		$$.vars=$1.vars;

		YYSTYPE::variable var;
		var.shaderResourceType=$3.shaderResourceType;
		var.type		=$3.strs[0];
		var.identifier	=$3.strs[1];
		var.semantic	=$3.strs[2];
		var.storage		=$3.strs[3];
		var.templ		=$3.strs[4];
		var.default_	=$3.strs[5];
		var.num			=$3.num;
		var.has_default	=$3.token!=0;
		$$.vars->push_back(var);
		$$.strs[0]		=($1.strs[0]+",")+$3.strs[0];
	}
	| param_declaration
	{
		YYSTYPE::variable var;
		var.shaderResourceType=$1.shaderResourceType;
		var.type		=$1.strs[0];
		var.identifier	=$1.strs[1];
		var.semantic	=$1.strs[2];
		var.storage		=$1.strs[3];
		var.templ		=$1.strs[4];
		var.default_	=$1.strs[5];
		var.num			=$1.num;
		var.has_default	=$1.token!=0;
		$$.vars			=new vector<YYSTYPE::variable>;
		$$.vars->push_back(var);
		$$.strs[0]		=$1.strs[0];
	}
	| %empty
	{
		$$.vars = new vector<YYSTYPE::variable>;
		$$.strs[0]="";
	}

// For geometry shader, we must be able to cope with:
// point particleVertexOutput inp[1]
// and inout TriangleStream<particleGeometryOutput> SpriteStream

// storage is in/out/inout.
// param is a type followed by an identifier.
// location is a semantic preceded with a colon, e.g. :TEXCOORD0 or :3

// so we need to accept point, line and so on as storage types.
// we need for the name to be able to have an array dimension.
// and we need the type to be able to have a template.
param_declaration : type_qualifier storage param location
	{
		$$.strs[0]	=$3.strs[0];			// type
		$$.strs[1]	=$3.strs[1];			// name
		$$.strs[2]	=$4.strs[0];			// semantic
		$$.strs[3]	=$2.strs[0];			// in/out, point, line
		$$.strs[4]	=$3.strs[2];			// optional template for type
		$$.strs[5] = $3.strs[3];			// optional default
		$$.num		=$3.num;				// if an array
		$$.token	=$3.token;
		$$.shaderResourceType	=$3.shaderResourceType;
	}

type_qualifier: CONST
	{
		$$.strs[0]	=$1.strs[0];
	} 
	| GROUPSHARED
	{
		$$.strs[0] = $1.strs[0];
	} 
	| %empty
	{
		$$.strs[0] = "";
	}
		
type : IDENTIFIER optional_template_type
	{
		$$.strs[0]=$1.strs[0];	// type
		$$.strs[1]=$2.strs[1];	// template if present
		$$.shaderResourceType		=(ShaderResourceType)0;
	} 
	| resource_type optional_template_type
	{
		$$.strs[0]=$1.strs[0];	// type
		$$.strs[1]=$2.strs[1];	// template if present
		$$.shaderResourceType		=ToShaderResourceType($1.token);
	}

param : type IDENTIFIER optional_index optional_default
	{
		$$.strs[0]	=$1.strs[0];	// type
		$$.strs[1]	=$2.strs[0];	// name
		$$.strs[2]	=$1.strs[1];	// template if present
		$$.strs[3]	=$4.strs[0];	// default
		$$.num		=$3.num;
		$$.token	=$4.token;
		$$.shaderResourceType	=$1.shaderResourceType;
	}

storage : STORAGEQ
	{
		$$.strs[0]=$1.strs[0];
	}
	| %empty
	{
		$$.strs[0]="";
	}

location : ':' NUM
	{
		$$.strs[0]="";
		$$.num=$2.num;
		$$.rType=REGISTER_INT;
	}
	| ':' IDENTIFIER
	{
		$$.strs[0]=$2.strs[0];
		$$.rType=REGISTER_NAME;
	}
	| %empty
	{
		$$.strs[0]="";
		$$.rType=REGISTER_NONE;
	};

optional_semantic : ':' IDENTIFIER
	{
		$$.strs[0]=$2.strs[0];
	}
	| %empty 
	{
		$$.strs[0]="";
	}	;
tech_def : pass_list
	{
		Technique *t = new Technique(*($1.passes));
		$$.tech = t;
		delete $1.passes;
	};

pass_list : pass_list pass_def
	{
		$$.passes = $1.passes;
		string name = $2.strs[0];
		Pass *p = $2.prog;
		if (p)
		{
			(*$$.passes)[name] = *(p);
		}
		delete $2.prog;
	}
	| pass_def
	{
		map < string, Pass > *m=new map < string, Pass >;
		$$.passes = m;
		string name = $1.strs[0];
		Pass *p = $1.prog;
		if (p)
		{
			Pass &newp = (*m)[name];
			newp= *p;
		}
		delete p;
	};

legacy_pass_def : PASS IDENTIFIER '{' prog_def '}'
	{
		$$.prog = $4.prog;
		$$.strs[0] = $2.strs[0];
	}

pass_def : legacy_pass_def
	{
		$$.prog = $1.prog;
		$$.strs[0] = $1.strs[0];
	} 
	| raytrace_pass_def
	{
	}

raytrace_pass_def : RAYTRACE_PASS IDENTIFIER '{' raytrace_def '}'
	{
		$$.prog = $4.prog;
		$$.strs[0] = $2.strs[0];
	}

prog_def : shaders_list
	{
		$$.prog = new Pass(buildPassState);
		buildPassState=PassState();
	};

raytrace_def : raytrace_shaders_list
	{
		$$.prog = new Pass(buildPassState);
		buildPassState=PassState();
	};
raytrace_shaders_list : raytrace_shaders_list raytrace_shader_def
	{
	} 
	| raytrace_shader_def
	{
	}
shaders_list : shaders_list shader_def
	{
			ShaderType sType				=$2.sType;
			string name						=$2.strs[0];
			buildPassState.shaders[sType]	=name;
	}
	| shader_def
	{
			string name						=$1.strs[0];
			ShaderType sType				=$1.sType;
			$$.strs[0]						=name;
			$$.sType						=sType;
			buildPassState.shaders[sType]	=name;
	}
	| shaders_list shader_fn
	{
		$$.strs[0]	="";
		$$.strs[1]	="";
		$$.sType	=(ShaderType)((int)NUM_OF_SHADER_TYPES+1);
	}
	| shader_fn
	{
		$$.strs[0]	="";
		$$.strs[1]	="";
		$$.sType	=(ShaderType)((int)NUM_OF_SHADER_TYPES+1);
	};
vec4 : IDENTIFIER '(' P_FLOAT ',' P_FLOAT ',' P_FLOAT ',' P_FLOAT ')'
	{
		$$.strs[0]=$1.strs[0]+"(";
		$$.strs[0]+=$3.strs[0]+",";
		$$.strs[0]+=$5.strs[0]+",";
		$$.strs[0]+=$7.strs[0]+",";
		$$.strs[0]+=$9.strs[0]+")";
	};
topology :  POINTLIST_TOPOLOGY		
	{
		  $$.strs[0]=$1.strs[0];
			$$.topology=POINTLIST;
	}
	| LINELIST_TOPOLOGY		
	{
		  $$.strs[0]=$1.strs[0];
			$$.topology=LINELIST;
	}
	| LINESTRIP_TOPOLOGY
	{
		  $$.strs[0]=$1.strs[0];
			$$.topology=LINESTRIP;
	}
	| TRIANGLELIST_TOPOLOGY
	{
		  $$.strs[0]=$1.strs[0];
			$$.topology=TRIANGLELIST;
	}
	| TRIANGLESTRIP_TOPOLOGY
	{
		$$.strs[0]=$1.strs[0];
		$$.topology=TRIANGLESTRIP;
	}			
	| LINELIST_ADJACENCY_TOPOLOGY
	{
		$$.strs[0]=$1.strs[0];
		$$.topology=LINELIST_ADJACENCY;
	}				
	| LINESTRIP_ADJACENCY_TOPOLOGY
	{
		$$.strs[0]=$1.strs[0];
		$$.topology=LINESTRIP_ADJACENCY;
	}				
	| TRIANGLELIST_ADJACENCY_TOPOLOGY
	{
		$$.strs[0]=$1.strs[0];
		$$.topology=TRIANGLELIST_ADJACENCY;
	}	
	| TRIANGLESTRIP_ADJACENCY_TOPOLOGY
	{
		$$.strs[0]=$1.strs[0];
		$$.topology=TRIANGLESTRIP_ADJACENCY;
	}		
shader_fn : SET_RASTERIZER_COMMAND '(' IDENTIFIER ')' ';'
	{
		 buildPassState.rasterizerState.objectName=$3.strs[0];
		 auto dec=gEffect->GetDeclaration(buildPassState.rasterizerState.objectName);
		 if(dec)
			 dec->ref_count++;
		 else
		 {
			 errSem("Undeclared Rasterizer State",$1.lineno);
		 }
	}
	| SET_TOPOLOGY_COMMAND '(' topology ')' ';'
	{
		 buildPassState.topologyState.apply=true;
		 buildPassState.topologyState.topology=$3.topology;
	}
	| SET_DEPTH_COMMAND '(' IDENTIFIER ',' NUM ')' ';'
	{
		string depth_name=$3.strs[0];
		buildPassState.depthStencilState.objectName=depth_name;
		auto dec=gEffect->GetDeclaration(buildPassState.depthStencilState.objectName);
		if(dec)
			dec->ref_count++;
		else
		{
			errSem("Undeclared Depth Stencil State",$1.lineno);
		}
		int index=$5.num;
	}
	| SET_RTFORMAT_COMMAND '(' IDENTIFIER ')' ';'
	{
		buildPassState.renderTargetFormatState.objectName=$3.strs[0];
		auto dec=gEffect->GetDeclaration(buildPassState.renderTargetFormatState.objectName);
		if(dec)
			dec->ref_count++;
		else
		{
			errSem("Undeclared Render Target Format  State",$1.lineno);
		}
	}
	| SET_BLEND_COMMAND '(' IDENTIFIER ',' vec4 ',' NUM ')' ';'
	{
		string blend_name=$3.strs[0];
		string vec4text=$5.strs[0];
		buildPassState.blendState.objectName=blend_name;
		buildPassState.blendState.sampleMask=$7.unum;
		// buildPassState.blendState.blendFactor=
		auto dec=gEffect->GetDeclaration(buildPassState.blendState.objectName);
		if(dec)
			dec->ref_count++;
		else
		{
			errSem("Undeclared Blend State",$1.lineno);
		}
		 //TODO: Implement vec4
	};

raytrace_shader_def : set_raytrace_shader '=' shader_compile_or_instance ';'
	{
		$$.strs[0]=$3.strs[0];
		buildPassState.shaders[$1.sType]=$3.strs[0];
		// the compiled shader:
		ShaderInstance *shaderInstance=gEffect->GetShaderInstance($3.strs[0],$1.sType);
	}
	| SET_HIT_GROUP IDENTIFIER '{' hit_group_shader_list '}' ';'
	{
		 $$.strs[0] = $2.strs[0];
		 buildPassState.raytraceHitGroups[$2.strs[0]] = buildRaytraceHitGroup;
		 buildRaytraceHitGroup = RaytraceHitGroup();
	} 
	| SET_MISS_SHADERS '{' miss_shader_list '}' ';'
	{
	} 
	| SET_CALLABLE_SHADERS '{' callable_shader_list '}' ';'
	{
	}
	| SET_RAY_TRACING_SHADER_CONFIG '{' ray_tracing_shader_config_list '}' ';'
	{
	}
	| SET_RAY_TRACING_PIPELINE_CONFIG '{' ray_tracing_pipeline_config_list '}' ';'
	{
	};

set_raytrace_shader : SET_RAY_GENERATION
	{
		$$.sType	=ShaderType::RAY_GENERATION_SHADER;
	}
	| SET_CALLABLE
	{
		$$.sType	=ShaderType::CALLABLE_SHADER;
	}
	| SET_MISS
	{
		$$.sType	=ShaderType::MISS_SHADER;
	}

hit_group_shader_list : set_hit_group_command
	{
	}
	| set_hit_group_command hit_group_shader_list
	{
	}

set_hit_group_command : set_hit_group_type '=' shader_compile_or_instance ';'
	{
		if($1.sType==ShaderType::CLOSEST_HIT_SHADER)
			buildRaytraceHitGroup.closestHit=$3.strs[0];
		if($1.sType==ShaderType::ANY_HIT_SHADER)
			buildRaytraceHitGroup.anyHit=$3.strs[0];
		if($1.sType==ShaderType::INTERSECTION_SHADER)
			buildRaytraceHitGroup.intersection=$3.strs[0];
		gEffect->GetShaderInstance($3.strs[0],$1.sType);
	}

set_hit_group_type : SET_CLOSEST_HIT
	{
		$$.sType	=ShaderType::CLOSEST_HIT_SHADER;
	}
	| SET_ANY_HIT
	{
		$$.sType	=ShaderType::ANY_HIT_SHADER;
	}
	| SET_INTERSECTION
	{
		$$.sType	=ShaderType::INTERSECTION_SHADER;
	}

miss_shader_list : set_miss_shader_command
	{
	}
	| set_miss_shader_command miss_shader_list
	{
	}

set_miss_shader_command : shader_compile_or_instance ';'
	{
		buildPassState.missShaders.push_back($1.strs[0]);
		gEffect->GetShaderInstance($1.strs[0], ShaderType::MISS_SHADER);
	}

callable_shader_list : set_callable_shader_command
	{
	}
	| set_callable_shader_command callable_shader_list
	{
	}

set_callable_shader_command : shader_compile_or_instance ';'
	{
		buildPassState.callableShaders.push_back($1.strs[0]);
		gEffect->GetShaderInstance($1.strs[0], ShaderType::CALLABLE_SHADER);
	}

ray_tracing_shader_config_list : set_ray_tracing_shader_config
	{
	}
	| set_ray_tracing_shader_config ray_tracing_shader_config_list
	{
	}
	| %empty
	{
	}

ray_tracing_pipeline_config_list : %empty
	{
	}
	| set_ray_tracing_pipeline_config ray_tracing_pipeline_config_list
	{
	}

set_ray_tracing_shader_config : SET_MAX_PAYLOAD_SIZE '=' NUM ';'
	{	
		buildPassState.maxPayloadSize= $3.unum;
	}
	| SET_MAX_ATTRIBUTE_SIZE '=' NUM ';'
	{	
		buildPassState.maxAttributeSize = $3.unum;
	}

set_ray_tracing_pipeline_config : SET_MAX_TRACE_RECURSION_DEPTH '=' NUM ';'
	{
		buildPassState.maxTraceRecursionDepth = $3.unum;
	}

shader_def : SHADER_COMMAND '(' shader_compile_or_instance ')' ';'
	{
		$$.strs[1]	="";
		$$.strs[0]	="";
		$$.sType	=(ShaderType)((int)NUM_OF_SHADER_TYPES+1);
		// the shader_variable is something like vs_main, for which we have a compile command like:
		//		VertexShader vs_main=CompileShader(430,VS_Main());
		// i.e. it's a combination of shadertype, profile, and function name.
		// so these are stored in gEffect->m_compiledSHaders.
		string shaderInstanceName=$3.strs[0];
		ShaderInstanceMap::iterator i=gEffect->m_shaderInstances.find(shaderInstanceName);
		if(i==gEffect->m_shaderInstances.end())
		{
			if(strcasecmp(shaderInstanceName.c_str(),"NULL")==0)
			{
			}
			else
			{
				ostringstream errMsg;
				errMsg<<"Unable to find compiled shader \""<<shaderInstanceName<<'\"';
				errSem(errMsg.str(), $3.lineno);
			}
		}
		else
		{
			ShaderInstance *shaderInstance	=i->second;
	
			$$.sCommand						=$1.sCommand;
			$$.sType						=$1.sType;
			sfx::ShaderType shaderType=$1.sType;
			shaderInstance->shaderType=shaderType;
			// If it's a streamout, set it as vertex, not geometry shader.
			if(shaderType==GEOMETRY_SHADER&&shaderInstance->shaderType==VERTEX_SHADER)
			{
				std::cout<<"Using streamout vertex shader for "<<i->first.c_str()<<std::endl;
				shaderInstanceName="gsConstructed";// to be discarded later. PS4 uses the Vertex shader directly for ConstructGS
				// so actually this will be regarded as a vertex shader, replacing the pure vertex shader.
			}
			$$.strs[0]=shaderInstanceName;
		}
	};

shader_compile_or_instance : IDENTIFIER
	{
	// an identifier for a shader instance could be an existing instance, or just a function name. For the latter, we create a default instance.
		string shaderInstanceName	=$1.strs[0];
		// Get or create:
		gEffect->GetShaderInstance(shaderInstanceName,UNKNOWN_SHADER_TYPE);
		$$.strs[0]					=shaderInstanceName;
		$$.num						=0;
		$$.lineno					=$1.lineno;
	}
	| shader_compile
	{
		string shaderInstanceName	=$1.strs[0];
		// Get or create:
		gEffect->GetShaderInstance(shaderInstanceName,UNKNOWN_SHADER_TYPE);
		$$.strs[0]					=shaderInstanceName;
		$$.num						=0;
		$$.lineno					=$1.lineno;
	}
shader_compile : CONSTRUCT_GS '(' IDENTIFIER ',' QUOTED_STRING ')'
	{
		//"POSITION.xyz;TYPE0.x;VELOCITY0.xyz"
		// For PS4, you can actually just stream straight from a vertex shader.
		// use setVsShaderStreamoutEnable
		// setStreamoutBufferDimensions
		// Let's use:
		//			#pragma argument(gsstream="...") 
		$$.lineno										=$5.lineno;
		string vertexShaderName							=$3.strs[0];
		string declar									=$5.strs[0];
		if(gEffect->m_shaderInstances.find(vertexShaderName)!=gEffect->m_shaderInstances.end())
		{
			ShaderInstance *compiledVertexShader	=gEffect->m_shaderInstances[vertexShaderName];
			stringstream ss;
			ss << vertexShaderName<<"_streamout";
			// we duplicate the vertex shader that's mentioned:
			ShaderInstance *compiledStreamOutVertexShader	=new ShaderInstance(*compiledVertexShader);
			// slightly modify declaration to match PSSL streamout format:
			// declar already contains enclosing quotes:
			find_and_replace(declar,"\"POSITION","\"S_POSITION");
			//
			//Not properly documented: here is the old documentation from SDK2.5:
			//-gsstream <buff number>, <stride>,<entry_spec>[,<entry_spec>]
			//	GS stream definition. You can provide the following parameters:
			//	- buff_number: The stream being defined.
			//	- stride: Number of bytes in the array stride.
			//	- entry_spec: Each component to use in the output stream, identified by the semantic with swizzle mask:
			//	  elem_offset_0:elem_stream_0:elem_semantic_0.xyzw
			//	The entry spec can be repeated to define multiple components for the stream.
			//	For example,
			//	-gsstream 0,32,0:0:POSITION.xyzw,16:0:NORMAL.xyz
			//	initializes stream out 0, with an array stride of 32 bytes. The first entry at offset 0 is the x, y, z, and w components of POSITION from GS stream 0. The second entry at offset 16 is the x, y, and z components of NORMAL, also from GS stream 0.
			//
			int stream_num=0;
			int byte_stride=24;
			string ps4_declar=declar;//QuickFormat("%d,%d,":,stream_num,byte_stride)+declar;
			compiledStreamOutVertexShader->m_preamble	+=string("\n#pragma argument (gsstream="+ps4_declar+")\n");
			gEffect->m_shaderInstances[ss.str()]		=compiledStreamOutVertexShader;
			$$.strs[0]									=ss.str();
		}
	}
	| COMPILE_SHADER_INSTANCE '(' IDENTIFIER ',' IDENTIFIER optional_brackets ')' 
	{
		$$.lineno										=$5.lineno;
		string profileName								=$3.strs[0];
		string shaderName								=$5.strs[0];
		string shaderInstanceName						=(shaderName+"Compiled")+profileName;
		$$.strs[0]										=shaderInstanceName;
		ShaderInstance *shaderInstance					=NULL;
		if(gEffect->m_shaderInstances.find(shaderInstanceName)!=gEffect->m_shaderInstances.end())
			shaderInstance	=gEffect->m_shaderInstances[shaderInstanceName];
		else
		{
			shaderInstance=gEffect->AddShaderInstance(shaderInstanceName,shaderName,UNKNOWN_SHADER_TYPE,profileName,$3.lineno);
			if(!shaderInstance)
			{
				ostringstream errMsg;
				errMsg<<"Unable to find referenced shader \""<<shaderName<<'\"';
				errSem(errMsg.str(), $5.lineno);
				exit(1);
			}
		}
		$$.strs[1]=profileName;
		if(strcasecmp(shaderInstance->m_functionName.c_str(),"NULL")!=0)
		{
			Function *function=gEffect->GetFunction(shaderInstance->m_functionName,0);
			if(!function)
			{
				ostringstream errMsg;
				errMsg<<"Unable to find referenced shader \""<<shaderInstance->m_functionName<<"\" - make sure you declare it with the 'shader' directive.";
				errSem(errMsg.str(), $3.lineno);
			}
		}
	};


render_state_list : render_state_list render_state_command
	{
		$$.strs[0]		=$1.strs[0];
		$$.strs[0]		+="\n";
		$$.strs[0]		+=$2.strs[0];
		$$.lineno		=$2.lineno;
	}
	| render_state_command
	{
		$$.strs[0]		=$1.strs[0];
		$$.lineno		=$1.lineno;
	};
render_state_command : render_state_identifier '=' render_state_rvalue ';'
	{
		$$.lineno		=$3.lineno;
		string name		=$1.strs[0];
		string value	=$3.strs[0];
		$$.strs[0]		=((name+"=")+value)+";";
		int index		=$1.num;
		int ival		=$3.num;
		float fval		=$3.fnum;
		bool bval		=(ival!=0);
		if(renderStateType==RENDERTARGETFORMAT_STATE)
		{
			if(is_equal(name,"TargetFormat"))
				buildrtFormatState.formats[index]=toPixelOutputFmt(value);
			else
			{
				ostringstream str;
				str<<"Unknown render target format command: "<<name;
				errSem(str.str().c_str());
			}
		}
		if(renderStateType==SAMPLER_STATE)
		{
			if(is_equal(name,"Filter"))
				buildSamplerState.Filter=(FilterMode)ival;
			if(is_equal(name,"AddressU"))
				buildSamplerState.AddressU=(AddressMode)ival;
			if(is_equal(name,"AddressV"))
				buildSamplerState.AddressV=(AddressMode)ival;
			if(is_equal(name,"AddressW"))
				buildSamplerState.AddressW=(AddressMode)ival;
			if(is_equal(name,"Comparison"))
				buildSamplerState.depthComparison=(DepthComparison)ival;
		}
		if(renderStateType==RASTERIZER_STATE)
		{
			if(is_equal(name,"FillMode"))
				buildRasterizerState.fillMode=toFillMode(value);
			else if(is_equal(name,"CullMode"))
				buildRasterizerState.cullMode=toCullMode(value);
			else if(is_equal(name,"FrontCounterClockwise"))
				buildRasterizerState.FrontCounterClockwise=toBool(value);
			else if(is_equal(name,"DepthBias"))
				buildRasterizerState.DepthBias=ival;
			else if(is_equal(name,"DepthBiasClamp"))
				buildRasterizerState.DepthBiasClamp=fval;
			else if(is_equal(name,"SlopeScaledDepthBias"))
				buildRasterizerState.SlopeScaledDepthBias=fval;
			else if(is_equal(name,"DepthClipEnable"))
				buildRasterizerState.DepthClipEnable=toBool(value);
			else if(is_equal(name,"ScissorEnable"))
				buildRasterizerState.ScissorEnable=toBool(value);
			else if(is_equal(name,"MultisampleEnable"))
				buildRasterizerState.MultisampleEnable=toBool(value);
			else if(is_equal(name,"AntialiasedLineEnable"))
				buildRasterizerState.AntialiasedLineEnable=toBool(value);
			else
			{
				ostringstream str;
				str<<"Unknown rasterizer state command: "<<name;
				errSem(str.str().c_str());
			}
		}
		if(renderStateType==DEPTHSTENCIL_STATE)
		{
			if(is_equal(name,"DepthEnable"))
				buildDepthStencilState.DepthTestEnable		=toBool(value);
			else if(is_equal(name,"DepthWriteMask"))
			{
				if(is_equal(value,"ALL"))
					buildDepthStencilState.DepthWriteMask	=1;
				else if(is_equal(value,"ZERO"))
					buildDepthStencilState.DepthWriteMask	=0;
				else 
					errSem("Unknown depth write mask");
			}
			else if(is_equal(name,"DepthFunc"))
				buildDepthStencilState.DepthFunc=toDepthFunc(value);
			else
			{
				ostringstream str;
				str<<"Unknown DepthStencil state command: "<<name;
				errSem(str.str().c_str());
			}
		}
		if(renderStateType==BLEND_STATE)
		{
			if(is_equal(name,"SrcBlend"))
				buildBlendState.SrcBlend=toBlend(value);
			else if(is_equal(name,"DestBlend"))
				buildBlendState.DestBlend=toBlend(value);
			else if(is_equal(name,"BlendOp"))
				buildBlendState.BlendOp=toBlendOp(value);
			else if(is_equal(name,"SrcBlendAlpha"))
				buildBlendState.SrcBlendAlpha=toBlend(value);
			else if(is_equal(name,"DestBlendAlpha"))
				buildBlendState.DestBlendAlpha=toBlend(value);
			else if(is_equal(name,"BlendOpAlpha"))
				buildBlendState.BlendOpAlpha=toBlendOp(value);
			else if(is_equal(name,"AlphaToCoverageEnable"))
				buildBlendState.AlphaToCoverageEnable=toBool(value);
			else if(is_equal(name,"BlendEnable"))
				buildBlendState.BlendEnable[index]=toBool(value);
			else if(is_equal(name,"RenderTargetWriteMask"))
				buildBlendState.RenderTargetWriteMask[index]=ival;
			else
			{
				ostringstream str;
				str<<"Unknown blend state command: "<<name;
				errSem(str.str().c_str());
			}
		}
	};
	| ignore_line_statement
	{
			$$.lineno	=$1.lineno;
			$$.num		=-1;
	};
render_state_identifier : IDENTIFIER optional_index
	{
		$$.lineno	=$1.lineno;
		$$.strs[0]=$1.strs[0];
		$$.num=$2.num;
	}
	|
	sampler_state_identifier
	{
		$$.strs[0]=$1.strs[0];
		$$.num=$1.num;
	};
sampler_state_identifier : FILTER
	{
		$$.strs[0]=$1.strs[0];
		$$.num=$1.num;
	}
	| ADDRESS_U
	{
		$$.strs[0]=$1.strs[0];
		$$.num=$1.num;
	}
	| ADDRESS_V
	{
		$$.strs[0]=$1.strs[0];
		$$.num=$1.num;
	}
	| ADDRESS_W
	{
		$$.strs[0]=$1.strs[0];
		$$.num=$1.num;
	}
	| COMPARISON
	{
		$$.strs[0]=$1.strs[0];
		$$.num=$1.num;
	}
sampler_state_value : ADDRESS_WRAP
	{
		$$.strs[0]=$1.strs[0];
		$$.num=WRAP;
	}
	| ADDRESS_CLAMP
	{
		$$.strs[0]=$1.strs[0];
		$$.num=CLAMP;
	}
	| ADDRESS_MIRROR
	{
		$$.strs[0]=$1.strs[0];
		$$.num=MIRROR;
	}
	| FILTER_MIN_MAG_MIP_LINEAR
	{
		$$.strs[0]=$1.strs[0];
		$$.num= FilterMode::MIN_MAG_MIP_LINEAR;
	}
	| FILTER_MIN_MAG_MIP_POINT
	{
		$$.strs[0]=$1.strs[0];
		$$.num= FilterMode::MIN_MAG_MIP_POINT;
	}
	| FILTER_ANISOTROPIC
	{
		$$.strs[0] = $1.strs[0];
		$$.num = FilterMode::ANISOTROPIC;
	}
	| depth_comparison
	{
		$$.strs[0] = $1.strs[0];
		$$.num = $1.num;
	}
depth_comparison : D_NEVER
	{
		$$.num =0;
	}
	| D_ALWAYS
	{
		$$.num =1;
	}
	| D_LESS
	{
		$$.num =2;
	}
	| D_EQUAL
	{
		$$.num =3;
	}
	| D_LESS_EQUAL
	{
		$$.num =4;
	}
	| D_GREATER
	{
		$$.num =5;
	}
	| D_NOT_EQUAL
	{
		$$.num =6;
	}
	| D_GREATER_EQUAL
	{
		$$.num =7;
	}
optional_index : '[' number_exp ']'
	{
		$$.num=$2.num;
		$$.fnum=$2.fnum;
	}
	| %empty
	{
		$$.num=0;
	};

optional_brackets :'(' ')'
	{
	}
	| %empty
	{
	}

optional_default : '=' constant
	{
		$$.strs[0] = $2.strs[0];
		$$.token = 1;
	}
	| %empty
	{
		 $$.strs[0] = "";
		 $$.token = 0;
	}
render_state_rvalue : IDENTIFIER
	{
			$$.lineno=$1.lineno;
		$$.strs[0]=$1.strs[0];
	}
	| NUM
	{
		$$.lineno=$1.lineno;
		$$.num=$1.num;
	}
	| P_FLOAT
	{
		$$.lineno=$1.lineno;
		$$.fnum=$1.fnum;
	}
	| sampler_state_value
	{
		$$.lineno=$1.lineno;
		$$.strs[0]=$1.strs[0];
	}
%%

ShaderResourceType ToShaderResourceType(int t)
{
	switch (t)
	{
	case TEMPLATIZED_CONSTANT_BUFFER:
		return ShaderResourceType::TEMPLATIZED_CONSTANT_BUFFER;
	case RAYTRACE_ACCELERATION_STRUCT:
		return ShaderResourceType::RAYTRACE_ACCELERATION_STRUCT;
	case TEXTURE1D:
		return ShaderResourceType::TEXTURE_1D;
	case TEXTURE2D:
		return ShaderResourceType::TEXTURE_2D;
	case TEXTURE2DMS:
		return ShaderResourceType::TEXTURE_2DMS;
	case TEXTURE3D:
		return ShaderResourceType::TEXTURE_3D;
	case TEXTURECUBE:
		return ShaderResourceType::TEXTURE_CUBE;
	case TEXTURECUBE_ARRAY:
		return ShaderResourceType::TEXTURE_CUBE_ARRAY;
	case TEXTURE2D_ARRAY:
		return ShaderResourceType::TEXTURE_2D_ARRAY;
	case RW_TEXTURE1D:
		return ShaderResourceType::RW_TEXTURE_1D;
	case RW_TEXTURE2D:
		return ShaderResourceType::RW_TEXTURE_2D;
	case RW_TEXTURE3D:
		return ShaderResourceType::RW_TEXTURE_3D;
	case RW_TEXTURE2D_ARRAY:
		return ShaderResourceType::RW_TEXTURE_2D_ARRAY;
	case STRUCTUREDBUFFER:
		return ShaderResourceType::STRUCTURED_BUFFER;
	case RW_STRUCTUREDBUFFER:
		return ShaderResourceType::RW_STRUCTURED_BUFFER;
	case REGULARBUFFER:
		return ShaderResourceType::STRUCTURED_BUFFER;
	case RW_REGULARBUFFER:
		return ShaderResourceType::RW_STRUCTURED_BUFFER;
	default:
		errSem("Unknown Shader resource type!");
		return ShaderResourceType::UNKNOWN;
	};
}

int GetTextureDimension(ShaderResourceType t, bool array_as_2d)
{
	if ((t&ShaderResourceType::TEXTURE_1D) == ShaderResourceType::TEXTURE_1D)
		return 1;
	if ((t&ShaderResourceType::TEXTURE_3D)== ShaderResourceType::TEXTURE_3D)
		return 3;
	if ((t&ShaderResourceType::ARRAY) == ShaderResourceType::ARRAY)
		return array_as_2d ? 2 : 3;
	return 2;
}

bool IsMSAATexture(ShaderResourceType t)
{
	return ((t&ShaderResourceType::MS) == ShaderResourceType::MS);
}

bool IsRW(ShaderResourceType t)
{
	return ((t&ShaderResourceType::RW) == ShaderResourceType::RW);
}

bool IsArrayTexture(ShaderResourceType t)
{
	return ((t&ShaderResourceType::ARRAY) == ShaderResourceType::ARRAY);
}

bool IsCubemap(ShaderResourceType t)
{
	return ((t&ShaderResourceType::TEXTURE_CUBE) == ShaderResourceType::TEXTURE_CUBE);
}

bool IsTexture(ShaderResourceType t)
{
	return ((t&ShaderResourceType::TEXTURE) == ShaderResourceType::TEXTURE);
}

bool IsStructuredBuffer(ShaderResourceType t)
{
	return ((t&ShaderResourceType::STRUCTURED_BUFFER) == ShaderResourceType::STRUCTURED_BUFFER);
}

bool IsRWStructuredBuffer(ShaderResourceType t)
{
	return ((t&ShaderResourceType::RW_STRUCTURED_BUFFER) == ShaderResourceType::RW_STRUCTURED_BUFFER);
}

string GetSizeFunction(string textureName, string x, string y, string z)
{
	ostringstream full_expr;
	auto config = gEffect->GetConfig();
	if (config->getSizeExpression.size() > 0)
	{
		ShaderResourceType type = GetShaderResourceType(buildFunction, textureName);
		bool isImage = IsRW(type);
		bool isMsaa = IsMSAATexture(type);
		bool lod_param = !isImage && !isMsaa;
		int return_size = GetTextureDimension(type);
		string exp = config->getSizeExpression;
		if (isImage)
		{
			exp = config->getRWSizeExpression;
			// Legacy for GL
			find_and_replace(exp, "{type}", "imageSize");
		}
		else
		{
			// Legacy for GL
			find_and_replace(exp, "{type}", "textureSize");
		}
		string tempName = string("iv") + textureName;
		// Add sampler constructor
		if (type != ShaderResourceType::UNKNOWN)
		{
			find_and_replace(exp, "{return_size}", to_string(return_size));
			find_and_replace(exp, "{dim:{textureName}}", to_string(return_size));
		}
		find_and_replace(exp, "{dim:{textureName}}", string("{dim:") + textureName + "}");
		string nameToReplace = textureName;
		if (!isImage)
		{
			if (!config->combineInShader)
			{
				nameToReplace = GetSamplerConstructor(type, textureName, &buildFunction) + "(" + nameToReplace + "[0])";
			}
		}
		find_and_replace(exp, "{tmpName}", textureName);
		find_and_replace(exp, "{tempName}", tempName);
		find_and_replace(exp, "{textureName}", nameToReplace);
		// This case happens if the texture is passed as parameter with different name as the global,
		// we will defer this step
		if (type == ShaderResourceType::UNKNOWN)
		{
			find_and_replace(exp, "{args}", "{args" + textureName + "}");
		}
		else
		{
			if (lod_param && !isMsaa)
			{
				find_and_replace(exp, "{args}", ",0");
			}
			else
			{
				find_and_replace(exp, "{args}", "");
			}
		}
		full_expr << exp;
		if (type == ShaderResourceType::UNKNOWN)
		{
			full_expr << "{dim_check:" << textureName << "," << x << "," << y << "," << z << "," << tempName << "}";
		}
		else
		{
			if (return_size > 0 && x.size() > 0)
			{
				full_expr << x << " = " + tempName + ".x;";
			}
			if (return_size > 1 && y.size() > 0)
			{
				full_expr << y << " = " + tempName + ".y;";
			}
			if (return_size > 2 && z.size() > 0)
			{
				full_expr << z << " = " + tempName + ".z;";
			}
		}
	}
	else
	{
		full_expr << textureName << ".GetDimensions(" << x << "," << y;
		if(z.length())
			full_expr << ","<< z;
		full_expr<< ")";
	}
	return full_expr.str();
}

ShaderResourceType GetShaderResourceType(const Function &function, const string &textureName)
{
	for (vector<sfxstype::variable>::const_iterator i = function.parameters.begin(); i != function.parameters.end(); i++)
	{
		if (textureName == i->identifier)
		{
			return (ShaderResourceType)i->shaderResourceType;
		}
	}
	auto j = gEffect->GetDeclarations().find(textureName);
	if (j != gEffect->GetDeclarations().end() && j->second->declarationType == DeclarationType::TEXTURE)
		return ((DeclaredTexture*)j->second)->shaderResourceType;
	return ShaderResourceType::UNKNOWN;
}

extern  bool sfxError;
void sfxReset()
{
	sfxError=false;
	currentTechniqueGroup="";
	buildGroup.m_techniques.clear();
}

bool getSfxError()
{
	return sfxError;
}

void sfxWarning(const char* e)
{
	ostringstream errMsg;
	int lex_linenumber=sfxget_lineno();
	int true_linenumber=lex_linenumber+last_linenumber-global_linenumber;
	errMsg<<current_filenumber<<"("<< true_linenumber<<") : sfx warning: \""<<sfxget_text()<<"\" "<<e;
	gEffect->Log()<<errMsg.str().c_str();
}

void  sfxerror(const char* e)
{
	errSyn(e);
}

void errSyn(const char* e)
{
	ostringstream errMsg;
	int lex_linenumber=sfxget_lineno();
	int true_linenumber=lex_linenumber+last_linenumber-global_linenumber;
	errMsg<<current_filename<<"("<< true_linenumber<<") : sfx syntax error: \""<<sfxget_text()<<"\" "<<e;
	const char *st=GetStartModeText();
	if(st)
		errMsg<<" in "<<st;
	// throw std::runtime_error(errMsg.str());
	std::cerr<<errMsg.str().c_str()<<std::endl;
	sfxError=true;
}

void errSem(const string& str, int lex_linenumber)
{
	ostringstream errMsg;
	
	if(lex_linenumber==-1)
		lex_linenumber= sfxget_lineno();
	int true_linenumber=lex_linenumber+last_linenumber-global_linenumber;
	errMsg<<current_filename<<"("<<true_linenumber<<") : sfx error: "<<str;
	const char *st=GetStartModeText();
	if(st)
		errMsg<<" in "<<st;
	std::cerr<<errMsg.str().c_str()<<std::endl;
	sfxError=true;
}

bool IsRW(int token)
{
	switch(token)
	{
	case RW_TEXTURE3D:
	case RW_TEXTURE1D:
	case RW_TEXTURE2D:
	case RW_TEXTURE2D_ARRAY:
	case RW_TEXTURE3D_ARRAY:
	case RW_REGULARBUFFER:
	case RW_STRUCTUREDBUFFER:
		return true;
	default:
		return false;
	};
}
bool IsArray(int token)
{
	switch(token)
	{
	case TEXTURE2D_ARRAY:
	case TEXTURE3D_ARRAY:
	case TEXTURECUBE_ARRAY:
	case RW_TEXTURE2D_ARRAY:
	case RW_TEXTURE3D_ARRAY:
		return true;
	default:
		return false;
	};
}
bool IsCubemap(int token)
{
	switch(token)
	{
	case TEXTURECUBE:
	case TEXTURECUBE_ARRAY:
		return true;
	default:
		return false;
	};
}