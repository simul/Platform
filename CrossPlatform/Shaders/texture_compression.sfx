//--------------------------------------------------------------------------------------
// BC 1, 3, 4, 5
//--------------------------------------------------------------------------------------

// https://github.com/microsoft/Xbox-ATG-Samples

// MIT License
// 
// Copyright (c) Microsoft Corporation.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE

//--------------------------------------------------------------------------------------
// BlockCompress.hlsli
//
// Helper functions for block compression
//
// Advanced Technology Group (ATG)
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------------------

#include "shader_platform.sl"
#include "common.sl"
#include "sampler_states.sl"

// CUSTOMBUILD : warning X4714: sum of temp registers and indexable temp registers times 256 threads exceeds the recommended total 16384.  Performance may be reduced
//  This warning shows up in Debug mode due to the complexity of the unoptimized shaders, but it's harmless aside from the fact that the shaders will be slow in Debug
// #pragma warning(disable: 4714)

//--------------------------------------------------------------------------------------
// Name: ColorTo565
// Desc: Pack a 3-component color into a uint
//--------------------------------------------------------------------------------------
uint ColorTo565(float3 color)
{
	uint3 rgb = uint3(round(color * float3(31.0f, 63.0f, 31.0f)));
	return (rgb.r << 11) | (rgb.g << 5) | rgb.b;
}


//--------------------------------------------------------------------------------------
// Name: TexelToUV
// Desc: Convert from a texel to the UV coordinates used in a Gather call
//--------------------------------------------------------------------------------------
float2 TexelToUV(float2 texel, float oneOverTextureWidth)
{
	// We Gather from the bottom-right corner of the texel
	return (texel + 1.0f) * oneOverTextureWidth;
}


//--------------------------------------------------------------------------------------
// Name: LoadTexelsRGB
// Desc: Load the 16 RGB texels that form a block
//--------------------------------------------------------------------------------------
void LoadTexelsRGB(Texture2D tex, SamplerState samp, float oneOverTextureWidth, uint2 threadIDWithinDispatch, out float3 block[16])
{
	float2 uv = TexelToUV(float2(threadIDWithinDispatch * 4), oneOverTextureWidth);

	float4 red = tex.GatherRed(samp, uv, int2(0, 0));
	float4 green = tex.GatherGreen(samp, uv, int2(0, 0));
	float4 blue = tex.GatherBlue(samp, uv, int2(0, 0));
	block[0] = float3(red[3], green[3], blue[3]);
	block[1] = float3(red[2], green[2], blue[2]);
	block[4] = float3(red[0], green[0], blue[0]);
	block[5] = float3(red[1], green[1], blue[1]);

	red = tex.GatherRed(samp, uv, int2(2, 0));
	green = tex.GatherGreen(samp, uv, int2(2, 0));
	blue = tex.GatherBlue(samp, uv, int2(2, 0));
	block[2] = float3(red[3], green[3], blue[3]);
	block[3] = float3(red[2], green[2], blue[2]);
	block[6] = float3(red[0], green[0], blue[0]);
	block[7] = float3(red[1], green[1], blue[1]);

	red = tex.GatherRed(samp, uv, int2(0, 2));
	green = tex.GatherGreen(samp, uv, int2(0, 2));
	blue = tex.GatherBlue(samp, uv, int2(0, 2));
	block[8] = float3(red[3], green[3], blue[3]);
	block[9] = float3(red[2], green[2], blue[2]);
	block[12] = float3(red[0], green[0], blue[0]);
	block[13] = float3(red[1], green[1], blue[1]);

	red = tex.GatherRed(samp, uv, int2(2, 2));
	green = tex.GatherGreen(samp, uv, int2(2, 2));
	blue = tex.GatherBlue(samp, uv, int2(2, 2));
	block[10] = float3(red[3], green[3], blue[3]);
	block[11] = float3(red[2], green[2], blue[2]);
	block[14] = float3(red[0], green[0], blue[0]);
	block[15] = float3(red[1], green[1], blue[1]);
}


//--------------------------------------------------------------------------------------
// Name: LoadTexelsRGBBias
// Desc: Load the 16 RGB texels that form a block, with a mip bias
//--------------------------------------------------------------------------------------
void LoadTexelsRGBBias(Texture2D tex, SamplerState samp, float oneOverTextureSize, uint2 threadIDWithinDispatch, uint mipBias, out float3 block[16])
{
	// We need to use Sample rather than Gather/Load for the Bias functions, because low mips will read outside
	//  the texture boundary. When reading outside the boundary, Gather/Load return 0, but Sample can clamp
	float2 location = float2(threadIDWithinDispatch * 4) * oneOverTextureSize;
	block[0] = tex.SampleLevel(samp, location, mipBias, int2(0, 0)).rgb;
	block[1] = tex.SampleLevel(samp, location, mipBias, int2(1, 0)).rgb;
	block[2] = tex.SampleLevel(samp, location, mipBias, int2(2, 0)).rgb;
	block[3] = tex.SampleLevel(samp, location, mipBias, int2(3, 0)).rgb;
	block[4] = tex.SampleLevel(samp, location, mipBias, int2(0, 1)).rgb;
	block[5] = tex.SampleLevel(samp, location, mipBias, int2(1, 1)).rgb;
	block[6] = tex.SampleLevel(samp, location, mipBias, int2(2, 1)).rgb;
	block[7] = tex.SampleLevel(samp, location, mipBias, int2(3, 1)).rgb;
	block[8] = tex.SampleLevel(samp, location, mipBias, int2(0, 2)).rgb;
	block[9] = tex.SampleLevel(samp, location, mipBias, int2(1, 2)).rgb;
	block[10] = tex.SampleLevel(samp, location, mipBias, int2(2, 2)).rgb;
	block[11] = tex.SampleLevel(samp, location, mipBias, int2(3, 2)).rgb;
	block[12] = tex.SampleLevel(samp, location, mipBias, int2(0, 3)).rgb;
	block[13] = tex.SampleLevel(samp, location, mipBias, int2(1, 3)).rgb;
	block[14] = tex.SampleLevel(samp, location, mipBias, int2(2, 3)).rgb;
	block[15] = tex.SampleLevel(samp, location, mipBias, int2(3, 3)).rgb;
}


//--------------------------------------------------------------------------------------
// Name: LoadTexelsRGBA
// Desc: Load the 16 RGBA texels that form a block
//--------------------------------------------------------------------------------------
void LoadTexelsRGBA(Texture2D tex, uint2 threadIDWithinDispatch, out float3 blockRGB[16], out float blockA[16])
{
	float4 rgba;
	int3 location = int3(threadIDWithinDispatch * 4, 0);
	rgba = tex.Load(location, int2(0, 0)); blockRGB[0] = rgba.rgb; blockA[0] = rgba.a;
	rgba = tex.Load(location, int2(1, 0)); blockRGB[1] = rgba.rgb; blockA[1] = rgba.a;
	rgba = tex.Load(location, int2(2, 0)); blockRGB[2] = rgba.rgb; blockA[2] = rgba.a;
	rgba = tex.Load(location, int2(3, 0)); blockRGB[3] = rgba.rgb; blockA[3] = rgba.a;
	rgba = tex.Load(location, int2(0, 1)); blockRGB[4] = rgba.rgb; blockA[4] = rgba.a;
	rgba = tex.Load(location, int2(1, 1)); blockRGB[5] = rgba.rgb; blockA[5] = rgba.a;
	rgba = tex.Load(location, int2(2, 1)); blockRGB[6] = rgba.rgb; blockA[6] = rgba.a;
	rgba = tex.Load(location, int2(3, 1)); blockRGB[7] = rgba.rgb; blockA[7] = rgba.a;
	rgba = tex.Load(location, int2(0, 2)); blockRGB[8] = rgba.rgb; blockA[8] = rgba.a;
	rgba = tex.Load(location, int2(1, 2)); blockRGB[9] = rgba.rgb; blockA[9] = rgba.a;
	rgba = tex.Load(location, int2(2, 2)); blockRGB[10] = rgba.rgb; blockA[10] = rgba.a;
	rgba = tex.Load(location, int2(3, 2)); blockRGB[11] = rgba.rgb; blockA[11] = rgba.a;
	rgba = tex.Load(location, int2(0, 3)); blockRGB[12] = rgba.rgb; blockA[12] = rgba.a;
	rgba = tex.Load(location, int2(1, 3)); blockRGB[13] = rgba.rgb; blockA[13] = rgba.a;
	rgba = tex.Load(location, int2(2, 3)); blockRGB[14] = rgba.rgb; blockA[14] = rgba.a;
	rgba = tex.Load(location, int2(3, 3)); blockRGB[15] = rgba.rgb; blockA[15] = rgba.a;
}


//--------------------------------------------------------------------------------------
// Name: LoadTexelsRGBABias
// Desc: Load the 16 RGBA texels that form a block, with a mip bias
//--------------------------------------------------------------------------------------
void LoadTexelsRGBABias(Texture2D tex, SamplerState samp, float oneOverTextureSize, uint2 threadIDWithinDispatch, uint mipBias, out float3 blockRGB[16], out float blockA[16])
{
	// We need to use Sample rather than Gather/Load for the Bias functions, because low mips will read outside
	//  the texture boundary. When reading outside the boundary, Gather/Load return 0, but Sample will clamp
	float4 rgba;
	float2 location = float2(threadIDWithinDispatch * 4) * oneOverTextureSize;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(0, 0)); blockRGB[0] = rgba.rgb; blockA[0] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(1, 0)); blockRGB[1] = rgba.rgb; blockA[1] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(2, 0)); blockRGB[2] = rgba.rgb; blockA[2] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(3, 0)); blockRGB[3] = rgba.rgb; blockA[3] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(0, 1)); blockRGB[4] = rgba.rgb; blockA[4] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(1, 1)); blockRGB[5] = rgba.rgb; blockA[5] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(2, 1)); blockRGB[6] = rgba.rgb; blockA[6] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(3, 1)); blockRGB[7] = rgba.rgb; blockA[7] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(0, 2)); blockRGB[8] = rgba.rgb; blockA[8] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(1, 2)); blockRGB[9] = rgba.rgb; blockA[9] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(2, 2)); blockRGB[10] = rgba.rgb; blockA[10] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(3, 2)); blockRGB[11] = rgba.rgb; blockA[11] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(0, 3)); blockRGB[12] = rgba.rgb; blockA[12] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(1, 3)); blockRGB[13] = rgba.rgb; blockA[13] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(2, 3)); blockRGB[14] = rgba.rgb; blockA[14] = rgba.a;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(3, 3)); blockRGB[15] = rgba.rgb; blockA[15] = rgba.a;
}


//--------------------------------------------------------------------------------------
// Name: LoadTexelsU
// Desc: Load the 16 U texels that form a block
//--------------------------------------------------------------------------------------
void LoadTexelsU(Texture2D tex, SamplerState samp, float oneOverTextureWidth, uint2 threadIDWithinDispatch, out float blockU[16])
{
	float2 uv = TexelToUV(float2(threadIDWithinDispatch * 4), oneOverTextureWidth);

	float4 red = tex.GatherRed(samp, uv, int2(0, 0));
	blockU[0] = red[3];
	blockU[1] = red[2];
	blockU[4] = red[0];
	blockU[5] = red[1];

	red = tex.GatherRed(samp, uv, int2(2, 0));
	blockU[2] = red[3];
	blockU[3] = red[2];
	blockU[6] = red[0];
	blockU[7] = red[1];

	red = tex.GatherRed(samp, uv, int2(0, 2));
	blockU[8] = red[3];
	blockU[9] = red[2];
	blockU[12] = red[0];
	blockU[13] = red[1];

	red = tex.GatherRed(samp, uv, int2(2, 2));
	blockU[10] = red[3];
	blockU[11] = red[2];
	blockU[14] = red[0];
	blockU[15] = red[1];
}


//--------------------------------------------------------------------------------------
// Name: LoadTexelsUV
// Desc: Load the 16 UV texels that form a block
//--------------------------------------------------------------------------------------
void LoadTexelsUV(Texture2D tex, SamplerState samp, float oneOverTextureWidth, uint2 threadIDWithinDispatch, out float blockU[16], out float blockV[16])
{
	float2 uv = TexelToUV(float2(threadIDWithinDispatch * 4), oneOverTextureWidth);

	float4 red = tex.GatherRed(samp, uv, int2(0, 0));
	float4 green = tex.GatherGreen(samp, uv, int2(0, 0));
	blockU[0] = red[3]; blockV[0] = green[3];
	blockU[1] = red[2]; blockV[1] = green[2];
	blockU[4] = red[0]; blockV[4] = green[0];
	blockU[5] = red[1]; blockV[5] = green[1];

	red = tex.GatherRed(samp, uv, int2(2, 0));
	green = tex.GatherGreen(samp, uv, int2(2, 0));
	blockU[2] = red[3]; blockV[2] = green[3];
	blockU[3] = red[2]; blockV[3] = green[2];
	blockU[6] = red[0]; blockV[6] = green[0];
	blockU[7] = red[1]; blockV[7] = green[1];

	red = tex.GatherRed(samp, uv, int2(0, 2));
	green = tex.GatherGreen(samp, uv, int2(0, 2));
	blockU[8] = red[3]; blockV[8] = green[3];
	blockU[9] = red[2]; blockV[9] = green[2];
	blockU[12] = red[0]; blockV[12] = green[0];
	blockU[13] = red[1]; blockV[13] = green[1];

	red = tex.GatherRed(samp, uv, int2(2, 2));
	green = tex.GatherGreen(samp, uv, int2(2, 2));
	blockU[10] = red[3]; blockV[10] = green[3];
	blockU[11] = red[2]; blockV[11] = green[2];
	blockU[14] = red[0]; blockV[14] = green[0];
	blockU[15] = red[1]; blockV[15] = green[1];
}


//--------------------------------------------------------------------------------------
// Name: LoadTexelsUVBias
// Desc: Load the 16 UV texels that form a block, with a mip bias
//--------------------------------------------------------------------------------------
void LoadTexelsUVBias(Texture2D tex, SamplerState samp, float oneOverTextureSize, uint2 threadIDWithinDispatch, uint mipBias, out float blockU[16], out float blockV[16])
{
	// We need to use Sample rather than Gather/Load for the Bias functions, because low mips will read outside
	//  the texture boundary. When reading outside the boundary, Gather/Load return 0, but Sample will clamp
	float4 rgba;
	float2 location = float2(threadIDWithinDispatch * 4) * oneOverTextureSize;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(0, 0)); blockU[0] = rgba.r; blockV[0] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(1, 0)); blockU[1] = rgba.r; blockV[1] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(2, 0)); blockU[2] = rgba.r; blockV[2] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(3, 0)); blockU[3] = rgba.r; blockV[3] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(0, 1)); blockU[4] = rgba.r; blockV[4] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(1, 1)); blockU[5] = rgba.r; blockV[5] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(2, 1)); blockU[6] = rgba.r; blockV[6] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(3, 1)); blockU[7] = rgba.r; blockV[7] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(0, 2)); blockU[8] = rgba.r; blockV[8] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(1, 2)); blockU[9] = rgba.r; blockV[9] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(2, 2)); blockU[10] = rgba.r; blockV[10] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(3, 2)); blockU[11] = rgba.r; blockV[11] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(0, 3)); blockU[12] = rgba.r; blockV[12] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(1, 3)); blockU[13] = rgba.r; blockV[13] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(2, 3)); blockU[14] = rgba.r; blockV[14] = rgba.g;
	rgba = tex.SampleLevel(samp, location, mipBias, int2(3, 3)); blockU[15] = rgba.r; blockV[15] = rgba.g;
}


//--------------------------------------------------------------------------------------
// Name: GetMinMaxChannel
// Desc: Get the min and max of a single channel
//--------------------------------------------------------------------------------------
void GetMinMaxChannel(float block[16], out float minC, out float maxC)
{
	minC = block[0];
	maxC = block[0];

	for (int i = 1; i < 16; ++i)
	{
		minC = min(minC, block[i]);
		maxC = max(maxC, block[i]);
	}
}


//--------------------------------------------------------------------------------------
// Name: GetMinMaxU
// Desc: Get the min and max of one channels (U)
//--------------------------------------------------------------------------------------
void GetMinMaxU(float blockU[16], out float minU, out float maxU)
{
	minU = blockU[0];
	maxU = blockU[0];

	for (int i = 1; i < 16; ++i)
	{
		minU = min(minU, blockU[i]);
		maxU = max(maxU, blockU[i]);
	}
}


//--------------------------------------------------------------------------------------
// Name: GetMinMaxUV
// Desc: Get the min and max of two channels (UV)
//--------------------------------------------------------------------------------------
void GetMinMaxUV(float blockU[16], float blockV[16], out float minU, out float maxU, out float minV, out float maxV)
{
	minU = blockU[0];
	maxU = blockU[0];
	minV = blockV[0];
	maxV = blockV[0];

	for (int i = 1; i < 16; ++i)
	{
		minU = min(minU, blockU[i]);
		maxU = max(maxU, blockU[i]);
		minV = min(minV, blockV[i]);
		maxV = max(maxV, blockV[i]);
	}
}


//--------------------------------------------------------------------------------------
// Name: GetMinMaxRGB
// Desc: Get the min and max of three channels (RGB)
//--------------------------------------------------------------------------------------
void GetMinMaxRGB(float3 colorBlock[16], out float3 minColor, out float3 maxColor)
{
	minColor = colorBlock[0];
	maxColor = colorBlock[0];

	for (int i = 1; i < 16; ++i)
	{
		minColor = min(minColor, colorBlock[i]);
		maxColor = max(maxColor, colorBlock[i]);
	}
}


//--------------------------------------------------------------------------------------
// Name: InsetMinMaxRGB
// Desc: Slightly inset the min and max color values to reduce RMS error.
//      This is recommended by van Waveren & Castano, "Real-Time YCoCg-DXT Compression"
//      http://www.nvidia.com/object/real-time-ycocg-dxt-compression.html
//--------------------------------------------------------------------------------------
void InsetMinMaxRGB(inout float3 minColor, inout float3 maxColor, float colorScale)
{
	// Since we have four points, (1/16) * (max-min) will give us half the distance between
	//  two points on the line in color space
	float3 offset = (1.0f / 16.0f) * (maxColor - minColor);

	// After applying the offset, we want to round up or down to the next integral color value (0 to 255)
	colorScale *= 255.0f;
	maxColor = ceil((maxColor - offset) * colorScale) / colorScale;
	minColor = floor((minColor + offset) * colorScale) / colorScale;
}


//--------------------------------------------------------------------------------------
// Name: GetIndicesRGB
// Desc: Calculate the BC block indices for each color in the block
//--------------------------------------------------------------------------------------
uint GetIndicesRGB(float3 block[16], float3 minColor, float3 maxColor)
{
	uint indices = 0;

	// For each input color, we need to select between one of the following output colors:
	//  0: maxColor
	//  1: (2/3)*maxColor + (1/3)*minColor
	//  2: (1/3)*maxColor + (2/3)*minColor
	//  3: minColor  
	//
	// We essentially just project (block[i] - maxColor) onto (minColor - maxColor), but we pull out
	//  a few constant terms.
	float3 diag = minColor - maxColor;
	float stepInc = 3.0f / dot(diag, diag); // Scale up by 3, because our indices are between 0 and 3
	diag *= stepInc;
	float c = stepInc * (dot(maxColor, maxColor) - dot(maxColor, minColor));

	for (int i = 15; i >= 0; --i)
	{
		// Compute the index for this block element
		uint index = uint(round(dot(block[i], diag) + c));

		// Now we need to convert our index into the somewhat unintuivive BC1 indexing scheme:
		//  0: maxColor
		//  1: minColor
		//  2: (2/3)*maxColor + (1/3)*minColor
		//  3: (1/3)*maxColor + (2/3)*minColor
		//
		// The mapping is:
		//  0 -> 0
		//  1 -> 2
		//  2 -> 3
		//  3 -> 1
		//
		// We can perform this mapping using bitwise operations, which is faster
		//  than predication or branching as long as it doesn't increase our register
		//  count too much. The mapping in binary looks like:
		//  00 -> 00
		//  01 -> 10
		//  10 -> 11
		//  11 -> 01
		//
		// Splitting it up by bit, the output looks like:
		//  bit1_out = bit0_in XOR bit1_in
		//  bit0_out = bit1_in 
		uint bit0_in = index & 1;
		uint bit1_in = index >> 1;
		indices |= ((bit0_in^bit1_in) << 1) | bit1_in;

		if (i != 0)
		{
			indices <<= 2;
		}
	}

	return indices;
}


//--------------------------------------------------------------------------------------
// Name: GetIndicesAlpha
// Desc: Calculate the BC block indices for an alpha channel
//--------------------------------------------------------------------------------------
void GetIndicesAlpha(float block[16], float minA, float maxA, inout uint2 packed)
{
	float d = minA - maxA;
	float stepInc = 7.0f / d;

	// Both packed.x and packed.y contain index values, so we need two loops

	uint index = 0;
	uint shift = 16;
	int i = 0;
	for (i = 0; i < 6; ++i)
	{
		// For each input alpha value, we need to select between one of eight output values
		//  0: maxA
		//  1: (6/7)*maxA + (1/7)*minA
		//  ...
		//  6: (1/7)*maxA + (6/3)*minA
		//  7: minA  
		index = uint(round(stepInc * (block[i] - maxA)));

		// Now we need to convert our index into the BC indexing scheme:
		//  0: maxA
		//  1: minA
		//  2: (6/7)*maxA + (1/7)*minA
		//  ...
		//  7: (1/7)*maxA + (6/3)*minA
		index += uint(index > 0) - (7 * uint(index == 7));

		packed.x |= (index << shift);
		shift += 3;
	}

	// The 6th index straddles the two uints
	packed.y |= (index >> 1);

	shift = 2;
	for (i = 6; i < 16; ++i)
	{
		index = uint(round((block[i] - maxA) * stepInc));
		index += uint(index > 0) - (7 * uint(index == 7));

		packed.y |= (index << shift);
		shift += 3;
	}
}


//--------------------------------------------------------------------------------------
// Name: CompressBC1Block
// Desc: Compress a BC1 block. colorScale is a scale value to be applied to the input 
//          colors; this used as an optimization when compressing two mips at a time.
//          When compressing only a single mip, colorScale is always 1.0
//--------------------------------------------------------------------------------------
uint2 CompressBC1Block(float3 block[16], float colorScale)
{
	float3 minColor, maxColor;
	GetMinMaxRGB(block, minColor, maxColor);

	// Inset the min and max values
	InsetMinMaxRGB(minColor, maxColor, colorScale);

	// Pack our colors into uints
	uint minColor565 = ColorTo565(colorScale * minColor);
	uint maxColor565 = ColorTo565(colorScale * maxColor);

	uint indices = 0;
	if (minColor565 < maxColor565)
	{
		indices = GetIndicesRGB(block, minColor, maxColor);
	}

	return uint2((minColor565 << 16) | maxColor565, indices);
}


//--------------------------------------------------------------------------------------
// Name: CompressBC3Block
// Desc: Compress a BC3 block. valueScale is a scale value to be applied to the input 
//          values; this used as an optimization when compressing two mips at a time.
//          When compressing only a single mip, valueScale is always 1.0
//--------------------------------------------------------------------------------------
uint4 CompressBC3Block(float3 blockRGB[16], float blockA[16], float valueScale)
{
	float3 minColor, maxColor;
	float minA, maxA;
	GetMinMaxRGB(blockRGB, minColor, maxColor);
	GetMinMaxChannel(blockA, minA, maxA);

	// Inset the min and max color values. We don't inset the alpha values
	//  because, while it may reduce the RMS error, it has a tendency to turn
	//  fully opaque texels partially transparent, which is probably not desirable.
	InsetMinMaxRGB(minColor, maxColor, valueScale);

	// Pack our colors and alpha values into uints
	uint minColor565 = ColorTo565(valueScale * minColor);
	uint maxColor565 = ColorTo565(valueScale * maxColor);
	uint minAPacked = uint(round(minA * valueScale * 255.0f));
	uint maxAPacked = uint(round(maxA * valueScale * 255.0f));

	uint indices = 0;
	if (minColor565 < maxColor565)
	{
		indices = GetIndicesRGB(blockRGB, minColor, maxColor);
	}

	uint2 outA = uint2((minAPacked << 8) | maxAPacked, 0);
	if (minAPacked < maxAPacked)
	{
		GetIndicesAlpha(blockA, minA, maxA, outA);
	}

	return uint4(outA.x, outA.y, (minColor565 << 16) | maxColor565, indices);
}

//--------------------------------------------------------------------------------------
// Name: CompressBC4Block
// Desc: Compress a BC4 block. valueScale is a scale value to be applied to the input 
//          values; this used as an optimization when compressing two mips at a time.
//          When compressing only a single mip, valueScale is always 1.0
//--------------------------------------------------------------------------------------
uint2 CompressBC4Block(float blockU[16], float valueScale)
{
	float minU, maxU;
	GetMinMaxU(blockU, minU, maxU);

	// Pack our min and max uv values
	uint minUPacked = uint(round(minU * valueScale * 255.0f));
	uint maxUPacked = uint(round(maxU * valueScale * 255.0f));

	uint2 outU = uint2((minUPacked << 8) | maxUPacked, 0);

	if (minUPacked < maxUPacked)
	{
		GetIndicesAlpha(blockU, minU, maxU, outU);
	}

	return uint2(outU.x, outU.y);
}

//--------------------------------------------------------------------------------------
// Name: CompressBC5Block
// Desc: Compress a BC5 block. valueScale is a scale value to be applied to the input 
//          values; this used as an optimization when compressing two mips at a time.
//          When compressing only a single mip, valueScale is always 1.0
//--------------------------------------------------------------------------------------
uint4 CompressBC5Block(float blockU[16], float blockV[16], float valueScale)
{
	float minU, maxU, minV, maxV;
	GetMinMaxUV(blockU, blockV, minU, maxU, minV, maxV);

	// Pack our min and max uv values
	uint minUPacked = uint(round(minU * valueScale * 255.0f));
	uint maxUPacked = uint(round(maxU * valueScale * 255.0f));
	uint minVPacked = uint(round(minV * valueScale * 255.0f));
	uint maxVPacked = uint(round(maxV * valueScale * 255.0f));

	uint2 outU = uint2((minUPacked << 8) | maxUPacked, 0);
	uint2 outV = uint2((minVPacked << 8) | maxVPacked, 0);

	if (minUPacked < maxUPacked)
	{
		GetIndicesAlpha(blockU, minU, maxU, outU);
	}

	if (minVPacked < maxVPacked)
	{
		GetIndicesAlpha(blockV, minV, maxV, outV);
	}

	return uint4(outU.x, outU.y, outV.x, outV.y);
}


//--------------------------------------------------------------------------------------
// Name: CalcTailMipsParams
// Desc: Calculate parameters used in the "compress tail mips" shaders
//--------------------------------------------------------------------------------------
void CalcTailMipsParams(uint2 threadIDWithinDispatch, out float oneOverTextureSize, out uint2 blockID, out uint mipBias)
{
	blockID = threadIDWithinDispatch;
	mipBias = 0;
	oneOverTextureSize = 1;

	// When compressing our tail mips, we only dispatch one 8x8 threadgroup. Different threads
	//  are selected to compress different mip levels based on the position of thr thread in
	//  the threadgroup.
	if (blockID.x < 4)
	{
		if (blockID.y < 4)
		{
			// 16x16 mip
			oneOverTextureSize = 1.0f / 16.0f;
		}
		else
		{
			// 1x1 mip
			mipBias = 4;
			blockID.y -= 4;
		}
	}
	else if (blockID.x < 6)
	{
		// 8x8 mip
		mipBias = 1;
		blockID -= float2(4, 4);
		oneOverTextureSize = 1.0f / 8.0f;
	}
	else if (blockID.x < 7)
	{
		// 4x4 mip
		mipBias = 2;
		blockID -= float2(6, 6);
		oneOverTextureSize = 1.0f / 4.0f;
	}
	else if (blockID.x < 8)
	{
		// 2x2 mip
		mipBias = 3;
		blockID -= float2(7, 7);
		oneOverTextureSize = 1.0f / 2.0f;
	}
}

//--------------------------------------------------------------------------------------
// BC1Compress.hlsl
//
// Fast block compression ComputeShader for BC1
//
// Advanced Technology Group (ATG)
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------------------

Texture2D g_texIn : register(t0);

RWTexture2D<uint2> g_texMip0OutBC1 : register(u0);    // Output BC1 texture as R32G32_UINT 
RWTexture2D<uint4> g_texMip0OutBC3 : register(u0);    // Output BC3 texture as R32G32B32A32_UINT
RWTexture2D<uint2> g_texMip0OutBC4 : register(u0);    // Output BC4 texture as R32G32_UINT 
RWTexture2D<uint4> g_texMip0OutBC5 : register(u0);    // Output BC5 texture as R32G32B32A32_UINT

//--------------------------------------------------------------------------------------
// BC1 Compress one mip level
//--------------------------------------------------------------------------------------
CS_LAYOUT(8, 8, 1)
shader void CS_BC1Compress(uint3 threadIDWithinDispatch : SV_DispatchThreadID)
{
	float g_oneOverTextureWidth = 0.0f;
	float2 g_texInDim;
	g_texIn.GetDimensions(g_texInDim.x, g_texInDim.y);
	g_oneOverTextureWidth = 1.0f / g_texInDim.x;
	
	float3 block[16];
	LoadTexelsRGB(g_texIn, samplerStateNearest, g_oneOverTextureWidth, threadIDWithinDispatch.xy, block);

	g_texMip0OutBC1[threadIDWithinDispatch.xy] = CompressBC1Block(block, 1.0f);
}

//--------------------------------------------------------------------------------------
// BC3 Compress one mip level
//--------------------------------------------------------------------------------------
CS_LAYOUT(8, 8, 1)
shader void CS_BC3Compress(uint3 threadIDWithinDispatch : SV_DispatchThreadID)
{
	float3 blockRGB[16];
	float blockA[16];
	LoadTexelsRGBA(g_texIn, threadIDWithinDispatch.xy, blockRGB, blockA);

	g_texMip0OutBC3[threadIDWithinDispatch.xy] = CompressBC3Block(blockRGB, blockA, 1.0f);
}

//--------------------------------------------------------------------------------------
// BC4 Compress one mip level
//--------------------------------------------------------------------------------------
CS_LAYOUT(8, 8, 1)
shader void CS_BC4Compress(uint3 threadIDWithinDispatch : SV_DispatchThreadID)
{
	float g_oneOverTextureWidth = 0.0f;
	float2 g_texInDim;
	g_texIn.GetDimensions(g_texInDim.x, g_texInDim.y);
	g_oneOverTextureWidth = 1.0f / g_texInDim.x;
	
	float blockU[16];
	LoadTexelsU(g_texIn, samplerStateNearest, g_oneOverTextureWidth, threadIDWithinDispatch.xy, blockU);

	g_texMip0OutBC4[threadIDWithinDispatch.xy] = CompressBC4Block(blockU, 1.0f);
}

//--------------------------------------------------------------------------------------
// BC5 Compress one mip level
//--------------------------------------------------------------------------------------
CS_LAYOUT(8, 8, 1)
shader void CS_BC5Compress(uint3 threadIDWithinDispatch : SV_DispatchThreadID)
{
	float g_oneOverTextureWidth = 0.0f;
	float2 g_texInDim;
	g_texIn.GetDimensions(g_texInDim.x, g_texInDim.y);
	g_oneOverTextureWidth = 1.0f / g_texInDim.x;
	
	float blockU[16], blockV[16];
	LoadTexelsUV(g_texIn, samplerStateNearest, g_oneOverTextureWidth, threadIDWithinDispatch.xy, blockU, blockV);

	g_texMip0OutBC5[threadIDWithinDispatch.xy] = CompressBC5Block(blockU, blockV, 1.0f);
}

//--------------------------------------------------------------------------------------
// BC 7
//--------------------------------------------------------------------------------------

// https://github.com/microsoft/DirectXTex/blob/main/DirectXTex/Shaders/BC7Encode.hlsl
//
//--------------------------------------------------------------------------------------
// File: BC7Encode.hlsl
//
// The Compute Shader for BC7 Encoder
//
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
//--------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------
// BC 7 Defines
//--------------------------------------------------------------------------------------

#define REF_DEVICE

#define CHAR_LENGTH			8
#define NCHANNELS			4
#define	BC7_UNORM			98
#define MAX_UINT			0xFFFFFFFF
#define MIN_UINT			0

//--------------------------------------------------------------------------------------
// BC 7 Tables
//--------------------------------------------------------------------------------------

static const uint candidateSectionBit[64] = //Associated to partition 0-63
{
	0xCCCC, 0x8888, 0xEEEE, 0xECC8,
	0xC880, 0xFEEC, 0xFEC8, 0xEC80,
	0xC800, 0xFFEC, 0xFE80, 0xE800,
	0xFFE8, 0xFF00, 0xFFF0, 0xF000,
	0xF710, 0x008E, 0x7100, 0x08CE,
	0x008C, 0x7310, 0x3100, 0x8CCE,
	0x088C, 0x3110, 0x6666, 0x366C,
	0x17E8, 0x0FF0, 0x718E, 0x399C,
	0xaaaa, 0xf0f0, 0x5a5a, 0x33cc,
	0x3c3c, 0x55aa, 0x9696, 0xa55a,
	0x73ce, 0x13c8, 0x324c, 0x3bdc,
	0x6996, 0xc33c, 0x9966, 0x660,
	0x272, 0x4e4, 0x4e40, 0x2720,
	0xc936, 0x936c, 0x39c6, 0x639c,
	0x9336, 0x9cc6, 0x817e, 0xe718,
	0xccf0, 0xfcc, 0x7744, 0xee22,
};
static const uint candidateSectionBit2[64] = //Associated to partition 64-127
{
	0xaa685050, 0x6a5a5040, 0x5a5a4200, 0x5450a0a8,
	0xa5a50000, 0xa0a05050, 0x5555a0a0, 0x5a5a5050,
	0xaa550000, 0xaa555500, 0xaaaa5500, 0x90909090,
	0x94949494, 0xa4a4a4a4, 0xa9a59450, 0x2a0a4250,
	0xa5945040, 0x0a425054, 0xa5a5a500, 0x55a0a0a0,
	0xa8a85454, 0x6a6a4040, 0xa4a45000, 0x1a1a0500,
	0x0050a4a4, 0xaaa59090, 0x14696914, 0x69691400,
	0xa08585a0, 0xaa821414, 0x50a4a450, 0x6a5a0200,
	0xa9a58000, 0x5090a0a8, 0xa8a09050, 0x24242424,
	0x00aa5500, 0x24924924, 0x24499224, 0x50a50a50,
	0x500aa550, 0xaaaa4444, 0x66660000, 0xa5a0a5a0,
	0x50a050a0, 0x69286928, 0x44aaaa44, 0x66666600,
	0xaa444444, 0x54a854a8, 0x95809580, 0x96969600,
	0xa85454a8, 0x80959580, 0xaa141414, 0x96960000,
	0xaaaa1414, 0xa05050a0, 0xa0a5a5a0, 0x96000000,
	0x40804080, 0xa9a8a9a8, 0xaaaaaa44, 0x2a4a5254,
};
static const uint2 candidateFixUpIndex1D[128] =
{
	{15, 0},{15, 0},{15, 0},{15, 0},
	{15, 0},{15, 0},{15, 0},{15, 0},
	{15, 0},{15, 0},{15, 0},{15, 0},
	{15, 0},{15, 0},{15, 0},{15, 0},
	{15, 0},{ 2, 0},{ 8, 0},{ 2, 0},
	{ 2, 0},{ 8, 0},{ 8, 0},{15, 0},
	{ 2, 0},{ 8, 0},{ 2, 0},{ 2, 0},
	{ 8, 0},{ 8, 0},{ 2, 0},{ 2, 0},

	{15, 0},{15, 0},{ 6, 0},{ 8, 0},
	{ 2, 0},{ 8, 0},{15, 0},{15, 0},
	{ 2, 0},{ 8, 0},{ 2, 0},{ 2, 0},
	{ 2, 0},{15, 0},{15, 0},{ 6, 0},
	{ 6, 0},{ 2, 0},{ 6, 0},{ 8, 0},
	{15, 0},{15, 0},{ 2, 0},{ 2, 0},
	{15, 0},{15, 0},{15, 0},{15, 0},
	{15, 0},{ 2, 0},{ 2, 0},{15, 0},
	//candidateFixUpIndex1D[i][1], i < 64 should not be used

	{ 3,15},{ 3, 8},{15, 8},{15, 3},
	{ 8,15},{ 3,15},{15, 3},{15, 8},
	{ 8,15},{ 8,15},{ 6,15},{ 6,15},
	{ 6,15},{ 5,15},{ 3,15},{ 3, 8},
	{ 3,15},{ 3, 8},{ 8,15},{15, 3},
	{ 3,15},{ 3, 8},{ 6,15},{10, 8},
	{ 5, 3},{ 8,15},{ 8, 6},{ 6,10},
	{ 8,15},{ 5,15},{15,10},{15, 8},

	{ 8,15},{15, 3},{ 3,15},{ 5,10},
	{ 6,10},{10, 8},{ 8, 9},{15,10},
	{15, 6},{ 3,15},{15, 8},{ 5,15},
	{15, 3},{15, 6},{15, 6},{15, 8}, //The Spec doesn't mark the first fixed up index in this row, so I apply 15 for them, and seems correct
	{ 3,15},{15, 3},{ 5,15},{ 5,15},
	{ 5,15},{ 8,15},{ 5,15},{10,15},
	{ 5,15},{10,15},{ 8,15},{13,15},
	{15, 3},{12,15},{ 3,15},{ 3, 8},
};
static const uint2 candidateFixUpIndex1DOrdered[128] = //Same with candidateFixUpIndex1D but order the result when i >= 64
{
	{15, 0},{15, 0},{15, 0},{15, 0},
	{15, 0},{15, 0},{15, 0},{15, 0},
	{15, 0},{15, 0},{15, 0},{15, 0},
	{15, 0},{15, 0},{15, 0},{15, 0},
	{15, 0},{ 2, 0},{ 8, 0},{ 2, 0},
	{ 2, 0},{ 8, 0},{ 8, 0},{15, 0},
	{ 2, 0},{ 8, 0},{ 2, 0},{ 2, 0},
	{ 8, 0},{ 8, 0},{ 2, 0},{ 2, 0},

	{15, 0},{15, 0},{ 6, 0},{ 8, 0},
	{ 2, 0},{ 8, 0},{15, 0},{15, 0},
	{ 2, 0},{ 8, 0},{ 2, 0},{ 2, 0},
	{ 2, 0},{15, 0},{15, 0},{ 6, 0},
	{ 6, 0},{ 2, 0},{ 6, 0},{ 8, 0},
	{15, 0},{15, 0},{ 2, 0},{ 2, 0},
	{15, 0},{15, 0},{15, 0},{15, 0},
	{15, 0},{ 2, 0},{ 2, 0},{15, 0},
	//candidateFixUpIndex1DOrdered[i][1], i < 64 should not be used

	{ 3,15},{ 3, 8},{ 8,15},{ 3,15},
	{ 8,15},{ 3,15},{ 3,15},{ 8,15},
	{ 8,15},{ 8,15},{ 6,15},{ 6,15},
	{ 6,15},{ 5,15},{ 3,15},{ 3, 8},
	{ 3,15},{ 3, 8},{ 8,15},{ 3,15},
	{ 3,15},{ 3, 8},{ 6,15},{ 8,10},
	{ 3, 5},{ 8,15},{ 6, 8},{ 6,10},
	{ 8,15},{ 5,15},{10,15},{ 8,15},

	{ 8,15},{ 3,15},{ 3,15},{ 5,10},
	{ 6,10},{ 8,10},{ 8, 9},{10,15},
	{ 6,15},{ 3,15},{ 8,15},{ 5,15},
	{ 3,15},{ 6,15},{ 6,15},{ 8,15}, //The Spec doesn't mark the first fixed up index in this row, so I apply 15 for them, and seems correct
	{ 3,15},{ 3,15},{ 5,15},{ 5,15},
	{ 5,15},{ 8,15},{ 5,15},{10,15},
	{ 5,15},{10,15},{ 8,15},{13,15},
	{ 3,15},{12,15},{ 3,15},{ 3, 8},
};
//static const uint4x4 candidateRotation[4] = 
//{
//    {1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1},
//    {0,0,0,1},{0,1,0,0},{0,0,1,0},{1,0,0,0},
//    {1,0,0,0},{0,0,0,1},{0,0,1,0},{0,1,0,0},
//    {1,0,0,0},{0,1,0,0},{0,0,0,1},{0,0,1,0}
//};
//static const uint2 candidateIndexPrec[8] = {{3,0},{3,0},{2,0},{2,0},
//                                            {2,3}, //color index and alpha index can exchange
//                                            {2,2},{4,4},{2,2}};

static const uint aWeight[3][16] = { {0,  4,  9, 13, 17, 21, 26, 30, 34, 38, 43, 47, 51, 55, 60, 64},
									{0,  9, 18, 27, 37, 46, 55, 64,  0,  0,  0,  0,  0,  0,  0,  0},
									{0, 21, 43, 64,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0} };

//4 bit index: 0, 4, 9, 13, 17, 21, 26, 30, 34, 38, 43, 47, 51, 55, 60, 64
static const uint aStep[3][64] = { { 0, 0, 0, 1, 1, 1, 1, 2,
									2, 2, 2, 2, 3, 3, 3, 3,
									4, 4, 4, 4, 5, 5, 5, 5,
									6, 6, 6, 6, 6, 7, 7, 7,
									7, 8, 8, 8, 8, 9, 9, 9,
									9,10,10,10,10,10,11,11,
								   11,11,12,12,12,12,13,13,
								   13,13,14,14,14,14,15,15 },
	//3 bit index: 0, 9, 18, 27, 37, 46, 55, 64
		{ 0,0,0,0,0,1,1,1,
		1,1,1,1,1,1,2,2,
		2,2,2,2,2,2,2,3,
		3,3,3,3,3,3,3,3,
		3,4,4,4,4,4,4,4,
		4,4,5,5,5,5,5,5,
		5,5,5,6,6,6,6,6,
		6,6,6,6,7,7,7,7 },
	//2 bit index: 0, 21, 43, 64
		{ 0,0,0,0,0,0,0,0,
		0,0,0,1,1,1,1,1,
		1,1,1,1,1,1,1,1,
		1,1,1,1,1,1,1,1,
		1,2,2,2,2,2,2,2,
		2,2,2,2,2,2,2,2,
		2,2,2,2,2,2,3,3,
		3,3,3,3,3,3,3,3 } };

//--------------------------------------------------------------------------------------
// BC 7 Shader Resources
//--------------------------------------------------------------------------------------

Texture2D g_Input : register(t0);
StructuredBuffer<uint4> g_InBuff : register(t1);
RWStructuredBuffer<uint4> g_OutBuff : register(u0);

#define THREAD_GROUP_SIZE	64
#define BLOCK_SIZE_Y		4
#define BLOCK_SIZE_X		4
#define BLOCK_SIZE			(BLOCK_SIZE_Y * BLOCK_SIZE_X)

cbuffer BC7ConstantData : register(b0)
{
	uint g_tex_width;
	uint g_num_block_x;
	uint g_format;
	uint g_mode_id;
	uint g_start_block_id;
	uint g_num_total_blocks;
	float g_alpha_weight;
};

//--------------------------------------------------------------------------------------
// BC 7 Group Shared Data
//--------------------------------------------------------------------------------------

struct BufferShared
{
	uint4 pixel;
	uint error;
	uint mode;
	uint partition_;
	uint index_selector;
	uint rotation;
	uint4 endPoint_low;
	uint4 endPoint_high;
	uint4 endPoint_low_quantized;
	uint4 endPoint_high_quantized;
};
groupshared BufferShared shared_temp[THREAD_GROUP_SIZE];

//--------------------------------------------------------------------------------------
// BC 7 Functions
//--------------------------------------------------------------------------------------

uint4 quantize(uint4 color, uint uPrec)
{
	return (((color << 8u) + color) * ((1u << uPrec) - 1u) + 32768u) >> 16u;
}

uint4 unquantize(uint4 color, uint uPrec)
{
	color = color << (8 - uPrec);
	return color | (color >> uPrec);
}

struct Endpoint
{
	uint4 value[2];
};

Endpoint compress_endpoints0(inout Endpoint endPoint, uint2 P)
{
	Endpoint quantized;
	for (uint j = 0; j < 2; j++)
	{
		quantized.value[j].rgb = quantize(endPoint.value[j].rgbb, 5).rgb & 0xFFFFFFFE;
		quantized.value[j].rgb |= P[j];
		quantized.value[j].a = 0xFF;

		endPoint.value[j].rgb = unquantize(quantized.value[j].rgbb, 5).rgb;
		endPoint.value[j].a = 0xFF;

		quantized.value[j] <<= 3;
	}
	return quantized;
}
Endpoint compress_endpoints1(inout Endpoint endPoint, uint2 P)
{
	Endpoint quantized;
	for (uint j = 0; j < 2; j++)
	{
		quantized.value[j].rgb = quantize(endPoint.value[j].rgbb, 7).rgb & 0xFFFFFFFE;
		quantized.value[j].rgb |= P[j];
		quantized.value[j].a = 0xFF;

		endPoint.value[j].rgb = unquantize(quantized.value[j].rgbb, 7).rgb;
		endPoint.value[j].a = 0xFF;

		quantized.value[j] <<= 1;
	}
	return quantized;
}
Endpoint compress_endpoints2(inout Endpoint endPoint)
{
	Endpoint quantized;
	for (uint j = 0; j < 2; j++)
	{
		quantized.value[j].rgb = quantize(endPoint.value[j].rgbb, 5).rgb;
		quantized.value[j].a = 0xFF;

		endPoint.value[j].rgb = unquantize(quantized.value[j].rgbb, 5).rgb;
		endPoint.value[j].a = 0xFF;

		quantized.value[j] <<= 3;
	}
	return quantized;
}
Endpoint compress_endpoints3(inout Endpoint endPoint, uint2 P)
{
	Endpoint quantized;
	for (uint j = 0; j < 2; j++)
	{
		quantized.value[j].rgb = endPoint.value[j].rgb & 0xFFFFFFFE;
		quantized.value[j].rgb |= P[j];
		quantized.value[j].a = 0xFF;

		endPoint.value[j].rgb = quantized.value[j].rgb;
		endPoint.value[j].a = 0xFF;
	}
	return quantized;
}
Endpoint compress_endpoints4(inout Endpoint endPoint)
{
	Endpoint quantized;
	for (uint j = 0; j < 2; j++)
	{
		quantized.value[j].rgb = quantize(endPoint.value[j].rgbb, 5).rgb;
		quantized.value[j].a = quantize(endPoint.value[j].aaaa, 6).r;

		endPoint.value[j].rgb = unquantize(quantized.value[j].rgbb, 5).rgb;
		endPoint.value[j].a = unquantize(quantized.value[j].aaaa, 6).r;

		quantized.value[j].rgb <<= 3;
		quantized.value[j].a <<= 2;
	}
	return quantized;
}
Endpoint compress_endpoints5(inout Endpoint endPoint)
{
	Endpoint quantized;
	for (uint j = 0; j < 2; j++)
	{
		quantized.value[j].rgb = quantize(endPoint.value[j].rgbb, 7).rgb;
		quantized.value[j].a = endPoint.value[j].a;

		endPoint.value[j].rgb = unquantize(quantized.value[j].rgbb, 7).rgb;
		// endPoint.value[j].a   Alpha is full precision

		quantized.value[j].rgb <<= 1;
	}
	return quantized;
}
Endpoint compress_endpoints6(inout Endpoint endPoint, uint2 P)
{
	Endpoint quantized;
	for (uint j = 0; j < 2; j++)
	{
		quantized.value[j] = endPoint.value[j] & 0xFFFFFFFE;
		quantized.value[j] |= P[j];

		endPoint.value[j] = quantized.value[j];
	}
	return quantized;
}
Endpoint compress_endpoints7(inout Endpoint endPoint, uint2 P)
{
	Endpoint quantized;
	for (uint j = 0; j < 2; j++)
	{
		quantized.value[j] = quantize(endPoint.value[j], 6) & 0xFFFFFFFE;
		quantized.value[j] |= P[j];

		endPoint.value[j] = unquantize(quantized.value[j], 6);
	}
	quantized.value[0] <<= 2;
	quantized.value[1] <<= 2;
	return quantized;
}

#define get_end_point_l(subset) shared_temp[threadBase + subset].endPoint_low_quantized
#define get_end_point_h(subset) shared_temp[threadBase + subset].endPoint_high_quantized
#define get_color_index(index) shared_temp[threadBase + index].error
#define get_alpha_index(index) shared_temp[threadBase + index].mode

void block_package0(out uint4 block, uint partition_, uint threadBase)
{
	block.x = 0x01 | ((partition_ - 64) << 1)
		| ((get_end_point_l(0).r & 0xF0) <<  1) | ((get_end_point_h(0).r & 0xF0) <<  5)
		| ((get_end_point_l(1).r & 0xF0) <<  9) | ((get_end_point_h(1).r & 0xF0) << 13)
		| ((get_end_point_l(2).r & 0xF0) << 17) | ((get_end_point_h(2).r & 0xF0) << 21)
		| ((get_end_point_l(0).g & 0xF0) << 25);
	block.y = ((get_end_point_l(0).g & 0xF0) >>  7) | ((get_end_point_h(0).g & 0xF0) >>  3)
		| ((get_end_point_l(1).g & 0xF0) <<  1) | ((get_end_point_h(1).g & 0xF0) <<  5)
		| ((get_end_point_l(2).g & 0xF0) <<  9) | ((get_end_point_h(2).g & 0xF0) << 13)
		| ((get_end_point_l(0).b & 0xF0) << 17) | ((get_end_point_h(0).b & 0xF0) << 21)
		| ((get_end_point_l(1).b & 0xF0) << 25);
	block.z = ((get_end_point_l(1).b & 0xF0) >>  7) | ((get_end_point_h(1).b & 0xF0) >>  3)
		| ((get_end_point_l(2).b & 0xF0) <<  1) | ((get_end_point_h(2).b & 0xF0) <<  5)
		| ((get_end_point_l(0).r & 0x08) << 10) | ((get_end_point_h(0).r & 0x08) << 11)
		| ((get_end_point_l(1).r & 0x08) << 12) | ((get_end_point_h(1).r & 0x08) << 13)
		| ((get_end_point_l(2).r & 0x08) << 14) | ((get_end_point_h(2).r & 0x08) << 15)
		| (get_color_index(0) << 19);
	block.w = 0;
	uint i = 1;
	for (; i <= min(candidateFixUpIndex1DOrdered[partition_][0], 4); i++)
	{
		block.z |= get_color_index(i) << (i * 3 + 18);
	}
	if (candidateFixUpIndex1DOrdered[partition_][0] < 4) //i = 4
	{
		block.z |= get_color_index(4) << 29;
		i += 1;
	}
	else //i = 5
	{
		block.w |= (get_color_index(4) & 0x04) >> 2;
		for (; i <= candidateFixUpIndex1DOrdered[partition_][0]; i++)
			block.w |= get_color_index(i) << (i * 3 - 14);
	}
	for (; i <= candidateFixUpIndex1DOrdered[partition_][1]; i++)
	{
		block.w |= get_color_index(i) << (i * 3 - 15);
	}
	for (; i < 16; i++)
	{
		block.w |= get_color_index(i) << (i * 3 - 16);
	}
}
void block_package1(out uint4 block, uint partition_, uint threadBase)
{
	block.x = 0x02 | (partition_ << 2)
		| ((get_end_point_l(0).r & 0xFC) <<  6) | ((get_end_point_h(0).r & 0xFC) << 12)
		| ((get_end_point_l(1).r & 0xFC) << 18) | ((get_end_point_h(1).r & 0xFC) << 24);
	block.y = ((get_end_point_l(0).g & 0xFC) >>  2) | ((get_end_point_h(0).g & 0xFC) <<  4)
		| ((get_end_point_l(1).g & 0xFC) << 10) | ((get_end_point_h(1).g & 0xFC) << 16)
		| ((get_end_point_l(0).b & 0xFC) << 22) | ((get_end_point_h(0).b & 0xFC) << 28);
	block.z = ((get_end_point_h(0).b & 0xFC) >>  4) | ((get_end_point_l(1).b & 0xFC) <<  2)
		| ((get_end_point_h(1).b & 0xFC) <<  8)
		| ((get_end_point_l(0).r & 0x02) << 15) | ((get_end_point_l(1).r & 0x02) << 16)
		| (get_color_index(0) << 18);
	if (candidateFixUpIndex1DOrdered[partition_][0] == 15)
	{
		block.w = (get_color_index(15) << 30) | (get_color_index(14) << 27) | (get_color_index(13) << 24) | (get_color_index(12) << 21) | (get_color_index(11) << 18) | (get_color_index(10) << 15)
			| (get_color_index(9) << 12) | (get_color_index(8) << 9) | (get_color_index(7) << 6) | (get_color_index(6) << 3) | get_color_index(5);
		block.z |= (get_color_index(4) << 29) | (get_color_index(3) << 26) | (get_color_index(2) << 23) | (get_color_index(1) << 20) | (get_color_index(0) << 18);
	}
	else if (candidateFixUpIndex1DOrdered[partition_][0] == 2)
	{
		block.w = (get_color_index(15) << 29) | (get_color_index(14) << 26) | (get_color_index(13) << 23) | (get_color_index(12) << 20) | (get_color_index(11) << 17) | (get_color_index(10) << 14)
			| (get_color_index(9) << 11) | (get_color_index(8) << 8) | (get_color_index(7) << 5) | (get_color_index(6) << 2) | (get_color_index(5) >> 1);
		block.z |= (get_color_index(5) << 31) | (get_color_index(4) << 28) | (get_color_index(3) << 25) | (get_color_index(2) << 23) | (get_color_index(1) << 20) | (get_color_index(0) << 18);
	}
	else if (candidateFixUpIndex1DOrdered[partition_][0] == 8)
	{
		block.w = (get_color_index(15) << 29) | (get_color_index(14) << 26) | (get_color_index(13) << 23) | (get_color_index(12) << 20) | (get_color_index(11) << 17) | (get_color_index(10) << 14)
			| (get_color_index(9) << 11) | (get_color_index(8) << 9) | (get_color_index(7) << 6) | (get_color_index(6) << 3) | get_color_index(5);
		block.z |= (get_color_index(4) << 29) | (get_color_index(3) << 26) | (get_color_index(2) << 23) | (get_color_index(1) << 20) | (get_color_index(0) << 18);
	}
	else //candidateFixUpIndex1DOrdered[partition_] == 6
	{
		block.w = (get_color_index(15) << 29) | (get_color_index(14) << 26) | (get_color_index(13) << 23) | (get_color_index(12) << 20) | (get_color_index(11) << 17) | (get_color_index(10) << 14)
			| (get_color_index(9) << 11) | (get_color_index(8) << 8) | (get_color_index(7) << 5) | (get_color_index(6) << 3) | get_color_index(5);
		block.z |= (get_color_index(4) << 29) | (get_color_index(3) << 26) | (get_color_index(2) << 23) | (get_color_index(1) << 20) | (get_color_index(0) << 18);
	}
}
void block_package2(out uint4 block, uint partition_, uint threadBase)
{
	block.x = 0x04 | ((partition_ - 64) << 3)
		| ((get_end_point_l(0).r & 0xF8) <<  6) | ((get_end_point_h(0).r & 0xF8) << 11)
		| ((get_end_point_l(1).r & 0xF8) << 16) | ((get_end_point_h(1).r & 0xF8) << 21)
		| ((get_end_point_l(2).r & 0xF8) << 26);
	block.y = ((get_end_point_l(2).r & 0xF8) >>  6) | ((get_end_point_h(2).r & 0xF8) >>  1)
		| ((get_end_point_l(0).g & 0xF8) <<  4) | ((get_end_point_h(0).g & 0xF8) <<  9)
		| ((get_end_point_l(1).g & 0xF8) << 14) | ((get_end_point_h(1).g & 0xF8) << 19)
		| ((get_end_point_l(2).g & 0xF8) << 24);
	block.z = ((get_end_point_h(2).g & 0xF8) >>  3) | ((get_end_point_l(0).b & 0xF8) <<  2)
		| ((get_end_point_h(0).b & 0xF8) <<  7)	| ((get_end_point_l(1).b & 0xF8) << 12)
		| ((get_end_point_h(1).b & 0xF8) << 17) | ((get_end_point_l(2).b & 0xF8) << 22)
		| ((get_end_point_h(2).b & 0xF8) << 27);
	block.w = ((get_end_point_h(2).b & 0xF8) >>  5)
		| (get_color_index(0) << 3);
	uint i = 1;
	for (; i <= candidateFixUpIndex1DOrdered[partition_][0]; i++)
	{
		block.w |= get_color_index(i) << (i * 2 + 2);
	}
	for (; i <= candidateFixUpIndex1DOrdered[partition_][1]; i++)
	{
		block.w |= get_color_index(i) << (i * 2 + 1);
	}
	for (; i < 16; i++)
	{
		block.w |= get_color_index(i) << (i * 2);
	}
}
void block_package3(out uint4 block, uint partition_, uint threadBase)
{
	block.x = 0x08 | (partition_ << 4)
		| ((get_end_point_l(0).r & 0xFE) <<  9) | ((get_end_point_h(0).r & 0xFE) << 16)
		| ((get_end_point_l(1).r & 0xFE) << 23) | ((get_end_point_h(1).r & 0xFE) << 30);
	block.y = ((get_end_point_h(1).r & 0xFE) >>  2) | ((get_end_point_l(0).g & 0xFE) <<  5)
		| ((get_end_point_h(0).g & 0xFE) << 12) | ((get_end_point_l(1).g & 0xFE) << 19)
		| ((get_end_point_h(1).g & 0xFE) << 26);
	block.z = ((get_end_point_h(1).g & 0xFE) >>  6) | ((get_end_point_l(0).b & 0xFE) <<  1)
		| ((get_end_point_h(0).b & 0xFE) <<  8) | ((get_end_point_l(1).b & 0xFE) << 15)
		| ((get_end_point_h(1).b & 0xFE) << 22)
		| ((get_end_point_l(0).r & 0x01) << 30) | ((get_end_point_h(0).r & 0x01) << 31);
	block.w = ((get_end_point_l(1).r & 0x01) <<  0) | ((get_end_point_h(1).r & 0x01) <<  1)
		| (get_color_index(0) << 2);
	uint i = 1;
	for (; i <= candidateFixUpIndex1DOrdered[partition_][0]; i++)
	{
		block.w |= get_color_index(i) << (i * 2 + 1);
	}
	for (; i < 16; i++)
	{
		block.w |= get_color_index(i) << (i * 2);
	}
}
void block_package4(out uint4 block, uint rotation, uint index_selector, uint threadBase)
{
	block.x = 0x10 | ((rotation & 3) << 5) | ((index_selector & 1) << 7)
		| ((get_end_point_l(0).r & 0xF8) <<  5) | ((get_end_point_h(0).r & 0xF8) << 10)
		| ((get_end_point_l(0).g & 0xF8) << 15) | ((get_end_point_h(0).g & 0xF8) << 20)
		| ((get_end_point_l(0).b & 0xF8) << 25);

	block.y = ((get_end_point_l(0).b & 0xF8) >>  7) | ((get_end_point_h(0).b & 0xF8) >>  2)
		| ((get_end_point_l(0).a & 0xFC) <<  4) | ((get_end_point_h(0).a & 0xFC) << 10)
		| ((get_color_index(0) & 1) << 18) | (get_color_index(1) << 19) | (get_color_index(2) << 21) | (get_color_index(3) << 23)
		| (get_color_index(4) << 25) | (get_color_index(5) << 27) | (get_color_index(6) << 29) | (get_color_index(7) << 31);

	block.z = (get_color_index(7) >>  1) | (get_color_index(8) <<  1) | (get_color_index(9) <<  3) | (get_color_index(10)<<  5)
		| (get_color_index(11)<<  7) | (get_color_index(12)<<  9) | (get_color_index(13)<< 11) | (get_color_index(14)<< 13)
		| (get_color_index(15)<< 15) | ((get_alpha_index(0) & 3) << 17) | (get_alpha_index(1) << 19) | (get_alpha_index(2) << 22)
		| (get_alpha_index(3) << 25) | (get_alpha_index(4) << 28) | (get_alpha_index(5) << 31);

	block.w = (get_alpha_index(5) >>  1) | (get_alpha_index(6) <<  2) | (get_alpha_index(7) <<  5) | (get_alpha_index(8) <<  8)
		| (get_alpha_index(9) << 11) | (get_alpha_index(10)<< 14) | (get_alpha_index(11)<< 17) | (get_alpha_index(12)<< 20)
		| (get_alpha_index(13)<< 23) | (get_alpha_index(14)<< 26) | (get_alpha_index(15)<< 29);
}
void block_package5(out uint4 block, uint rotation, uint threadBase)
{
	block.x = 0x20 | (rotation << 6)
		| ((get_end_point_l(0).r & 0xFE) <<  7) | ((get_end_point_h(0).r & 0xFE) << 14)
		| ((get_end_point_l(0).g & 0xFE) << 21) | ((get_end_point_h(0).g & 0xFE) << 28);
	block.y = ((get_end_point_h(0).g & 0xFE) >>  4) | ((get_end_point_l(0).b & 0xFE) <<  3)
		| ((get_end_point_h(0).b & 0xFE) << 10)	| (get_end_point_l(0).a << 18) | (get_end_point_h(0).a << 26);
	block.z = (get_end_point_h(0).a >>  6)
		| (get_color_index(0) <<  2) | (get_color_index(1) <<  3) | (get_color_index(2) <<  5) | (get_color_index(3) <<  7)
		| (get_color_index(4) <<  9) | (get_color_index(5) << 11) | (get_color_index(6) << 13) | (get_color_index(7) << 15)
		| (get_color_index(8) << 17) | (get_color_index(9) << 19) | (get_color_index(10)<< 21) | (get_color_index(11)<< 23)
		| (get_color_index(12)<< 25) | (get_color_index(13)<< 27) | (get_color_index(14)<< 29) | (get_color_index(15)<< 31);
	block.w = (get_color_index(15)>> 1) | (get_alpha_index(0) <<  1) | (get_alpha_index(1) <<  2) | (get_alpha_index(2) <<  4)
		| (get_alpha_index(3) <<  6) | (get_alpha_index(4) <<  8) | (get_alpha_index(5) << 10) | (get_alpha_index(6) << 12)
		| (get_alpha_index(7) << 14) | (get_alpha_index(8) << 16) | (get_alpha_index(9) << 18) | (get_alpha_index(10)<< 20)
		| (get_alpha_index(11)<< 22) | (get_alpha_index(12)<< 24) | (get_alpha_index(13)<< 26) | (get_alpha_index(14)<< 28)
		| (get_alpha_index(15)<< 30);
}
void block_package6(out uint4 block, uint threadBase)
{
	block.x = 0x40
		| ((get_end_point_l(0).r & 0xFE) <<  6) | ((get_end_point_h(0).r & 0xFE) << 13)
		| ((get_end_point_l(0).g & 0xFE) << 20) | ((get_end_point_h(0).g & 0xFE) << 27);
	block.y = ((get_end_point_h(0).g & 0xFE) >>  5) | ((get_end_point_l(0).b & 0xFE) <<  2)
		| ((get_end_point_h(0).b & 0xFE) <<  9)	| ((get_end_point_l(0).a & 0xFE) << 16)
		| ((get_end_point_h(0).a & 0xFE) << 23)
		| (get_end_point_l(0).r & 0x01) << 31;
	block.z = (get_end_point_h(0).r & 0x01)
		| (get_color_index(0) <<  1) | (get_color_index(1) <<  4) | (get_color_index(2) <<  8) | (get_color_index(3) << 12)
		| (get_color_index(4) << 16) | (get_color_index(5) << 20) | (get_color_index(6) << 24) | (get_color_index(7) << 28);
	block.w = (get_color_index(8) <<  0) | (get_color_index(9) <<  4) | (get_color_index(10)<<  8) | (get_color_index(11)<< 12)
		| (get_color_index(12)<< 16) | (get_color_index(13)<< 20) | (get_color_index(14)<< 24) | (get_color_index(15)<< 28);
}
void block_package7(out uint4 block, uint partition_, uint threadBase)
{
	block.x = 0x80 | (partition_ << 8)
		| ((get_end_point_l(0).r & 0xF8) << 11) | ((get_end_point_h(0).r & 0xF8) << 16)
		| ((get_end_point_l(1).r & 0xF8) << 21) | ((get_end_point_h(1).r & 0xF8) << 26);
	block.y = ((get_end_point_h(1).r & 0xF8) >>  6) | ((get_end_point_l(0).g & 0xF8) >>  1)
		| ((get_end_point_h(0).g & 0xF8) <<  4) | ((get_end_point_l(1).g & 0xF8) <<  9)
		| ((get_end_point_h(1).g & 0xF8) << 14)	| ((get_end_point_l(0).b & 0xF8) << 19)
		| ((get_end_point_h(0).b & 0xF8) << 24);
	block.z = ((get_end_point_l(1).b & 0xF8) >>  3)	| ((get_end_point_h(1).b & 0xF8) <<  2)
		| ((get_end_point_l(0).a & 0xF8) <<  7) | ((get_end_point_h(0).a & 0xF8) << 12)
		| ((get_end_point_l(1).a & 0xF8) << 17) | ((get_end_point_h(1).a & 0xF8) << 22)
		| ((get_end_point_l(0).r & 0x04) << 28) | ((get_end_point_h(0).r & 0x04) << 29);
	block.w = ((get_end_point_l(1).r & 0x04) >>  2) | ((get_end_point_h(1).r & 0x04) >>  1)
		| (get_color_index(0) <<  2);
	uint i = 1;
	for (; i <= candidateFixUpIndex1DOrdered[partition_][0]; i++)
	{
		block.w |= get_color_index(i) << (i * 2 + 1);
	}
	for (; i < 16; i++)
	{
		block.w |= get_color_index(i) << (i * 2);
	}
}

void swap(inout uint4 lhs, inout uint4 rhs)
{
	uint4 tmp = lhs;
	lhs = rhs;
	rhs = tmp;
}
void swap(inout uint3 lhs, inout uint3 rhs)
{
	uint3 tmp = lhs;
	lhs = rhs;
	rhs = tmp;
}
void swap(inout uint lhs, inout uint rhs)
{
	uint tmp = lhs;
	lhs = rhs;
	rhs = tmp;
}

uint ComputeError(in uint4 a, in uint4 b)
{
	return uint(dot(float3(a.rgb), float3(b.rgb))) + uint(g_alpha_weight * a.a * b.a);
}

void Ensure_A_Is_Larger(inout uint4 a, inout uint4 b)
{
	if (a.x < b.x)
		swap(a.x, b.x);
	if (a.y < b.y)
		swap(a.y, b.y);
	if (a.z < b.z)
		swap(a.z, b.z);
	if (a.w < b.w)
		swap(a.w, b.w);
}

//--------------------------------------------------------------------------------------
// BC7 - Try Modes 4, 5, 6
//--------------------------------------------------------------------------------------
CS_LAYOUT(THREAD_GROUP_SIZE, 1, 1)
shader void CS_BC7TryMode456(uint GI : SV_GroupIndex, uint3 groupID : SV_GroupID) // mode 4 5 6 all have 1 subset per block, and fix-up index is always index 0
{
	// we process 4 BC blocks per thread group
	const uint MAX_USED_THREAD = 16;                                                // pixels in a BC (block compressed) block
	uint BLOCK_IN_GROUP = THREAD_GROUP_SIZE / MAX_USED_THREAD;                      // the number of BC blocks a thread group processes = 64 / 16 = 4
	uint blockInGroup = GI / MAX_USED_THREAD;                                       // what BC block this thread is on within this thread group
	uint blockID = g_start_block_id + groupID.x * BLOCK_IN_GROUP + blockInGroup;    // what global BC block this thread is on
	uint threadBase = blockInGroup * MAX_USED_THREAD;                               // the first id of the pixel in this BC block in this thread group
	uint threadInBlock = GI - threadBase;                                           // id of the pixel in this BC block

#ifndef REF_DEVICE
	if (blockID >= g_num_total_blocks)
	{
		return;
	}
#endif

	uint block_y = blockID / g_num_block_x;
	uint block_x = blockID - block_y * g_num_block_x;
	uint base_x = block_x * BLOCK_SIZE_X;
	uint base_y = block_y * BLOCK_SIZE_Y;

	if (threadInBlock < 16)
	{
		shared_temp[GI].pixel = clamp(uint4(g_Input.Load(uint3(base_x + threadInBlock % 4, base_y + threadInBlock / 4, 0)) * 255), 0, 255);

		shared_temp[GI].endPoint_low = shared_temp[GI].pixel;
		shared_temp[GI].endPoint_high = shared_temp[GI].pixel;
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif

	if (threadInBlock < 8)
	{
		shared_temp[GI].endPoint_low = min(shared_temp[GI].endPoint_low, shared_temp[GI + 8].endPoint_low);
		shared_temp[GI].endPoint_high = max(shared_temp[GI].endPoint_high, shared_temp[GI + 8].endPoint_high);
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 4)
	{
		shared_temp[GI].endPoint_low = min(shared_temp[GI].endPoint_low, shared_temp[GI + 4].endPoint_low);
		shared_temp[GI].endPoint_high = max(shared_temp[GI].endPoint_high, shared_temp[GI + 4].endPoint_high);
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 2)
	{
		shared_temp[GI].endPoint_low = min(shared_temp[GI].endPoint_low, shared_temp[GI + 2].endPoint_low);
		shared_temp[GI].endPoint_high = max(shared_temp[GI].endPoint_high, shared_temp[GI + 2].endPoint_high);
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 1)
	{
		shared_temp[GI].endPoint_low = min(shared_temp[GI].endPoint_low, shared_temp[GI + 1].endPoint_low);
		shared_temp[GI].endPoint_high = max(shared_temp[GI].endPoint_high, shared_temp[GI + 1].endPoint_high);
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif

	Endpoint endPoint;
	endPoint.value[0] = shared_temp[threadBase].endPoint_low;
	endPoint.value[1] = shared_temp[threadBase].endPoint_high;

	uint error = 0xFFFFFFFF;
	uint mode = 0;
	uint index_selector = 0;
	uint rotation = 0;

	uint2 indexPrec;
	if (threadInBlock < 8) // all threads of threadInBlock < 8 will be working on trying out mode 4, since only mode 4 has index selector bit
	{
		if (0 == (threadInBlock & 1)) // thread 0, 2, 4, 6
		{
			//2 represents 2bit index precision; 1 represents 3bit index precision
			index_selector = 0;
			indexPrec = uint2(2, 1);
		}
		else                          // thread 1, 3, 5, 7
		{
			//2 represents 2bit index precision; 1 represents 3bit index precision
			index_selector = 1;
			indexPrec = uint2(1, 2);
		}
	}
	else
	{
		//2 represents 2bit index precision
		indexPrec = uint2(2, 2);
	}

	uint4 pixel_r;
	uint color_index;
	uint alpha_index;
	int4 span;
	int2 span_norm_sqr;
	int2 dotProduct;
	if (threadInBlock < 12) // Try mode 4 5 in threads 0..11
	{
		// mode 4 5 have component rotation
		if ((threadInBlock < 2) || (8 == threadInBlock))       // rotation = 0 in thread 0, 1
		{
			rotation = 0;
		}
		else if ((threadInBlock < 4) || (9 == threadInBlock))  // rotation = 1 in thread 2, 3
		{
			endPoint.value[0].ra = endPoint.value[0].ar;
			endPoint.value[1].ra = endPoint.value[1].ar;

			rotation = 1;
		}
		else if ((threadInBlock < 6) || (10 == threadInBlock)) // rotation = 2 in thread 4, 5
		{
			endPoint.value[0].ga = endPoint.value[0].ag;
			endPoint.value[1].ga = endPoint.value[1].ag;

			rotation = 2;
		}
		else if ((threadInBlock < 8) || (11 == threadInBlock)) // rotation = 3 in thread 6, 7
		{
			endPoint.value[0].ba = endPoint.value[0].ab;
			endPoint.value[1].ba = endPoint.value[1].ab;

			rotation = 3;
		}

		if (threadInBlock < 8)  // try mode 4 in threads 0..7
		{
			// mode 4 thread distribution
			// Thread           0	1	2	3	4	5	6	7
			// Rotation	        0	0	1	1	2	2	3	3
			// Index selector   0	1	0	1	0	1	0	1

			mode = 4;
			compress_endpoints4(endPoint);
		}
		else                    // try mode 5 in threads 8..11
		{
			// mode 5 thread distribution
			// Thread	 8	9  10  11
			// Rotation	 0	1   2   3

			mode = 5;
			compress_endpoints5(endPoint);
		}

		uint4 pixel = shared_temp[threadBase + 0].pixel;
		if (1 == rotation)
		{
			pixel.ra = pixel.ar;
		}
		else if (2 == rotation)
		{
			pixel.ga = pixel.ag;
		}
		else if (3 == rotation)
		{
			pixel.ba = pixel.ab;
		}

		span = int4(endPoint.value[1] - endPoint.value[0]);
		span_norm_sqr = int2(dot(float3(span.rgb), float3(span.rgb)), span.a * span.a);

		// in mode 4 5 6, end point 0 must be closer to pixel 0 than end point 1, because of the fix-up index is always index 0
		// TODO: this shouldn't be necessary here in error calculation
		/*
		dotProduct = int2( dot( span.rgb, pixel.rgb - endPoint[0].rgb ), span.a * ( pixel.a - endPoint[0].a ) );
		if ( span_norm_sqr.x > 0 && dotProduct.x > 0 && uint( dotProduct.x * 63.49999 ) > uint( 32 * span_norm_sqr.x ) )
		{
			span.rgb = -span.rgb;
			swap(endPoint[0].rgb, endPoint[1].rgb);
		}
		if ( span_norm_sqr.y > 0 && dotProduct.y > 0 && uint( dotProduct.y * 63.49999 ) > uint( 32 * span_norm_sqr.y ) )
		{
			span.a = -span.a;
			swap(endPoint[0].a, endPoint[1].a);
		}
		*/

		// should be the same as above
		dotProduct = int2(dot(float3(pixel.rgb - endPoint.value[0].rgb), float3(pixel.rgb - endPoint.value[0].rgb)), dot(float3(pixel.rgb - endPoint.value[1].rgb), float3(pixel.rgb - endPoint.value[1].rgb)));
		if (dotProduct.x > dotProduct.y)
		{
			span.rgb = -span.rgb;
			swap(endPoint.value[0].rgb, endPoint.value[1].rgb);
		}
		dotProduct = int2(dot(float(pixel.a - endPoint.value[0].a), float(pixel.a - endPoint.value[0].a)), dot(float(pixel.a - endPoint.value[1].a), float(pixel.a - endPoint.value[1].a)));
		if (dotProduct.x > dotProduct.y)
		{
			span.a = -span.a;
			swap(endPoint.value[0].a, endPoint.value[1].a);
		}

		error = 0;
		for (uint i = 0; i < 16; i++)
		{
			pixel = shared_temp[threadBase + i].pixel;
			if (1 == rotation)
			{
				pixel.ra = pixel.ar;
			}
			else if (2 == rotation)
			{
				pixel.ga = pixel.ag;
			}
			else if (3 == rotation)
			{
				pixel.ba = pixel.ab;
			}

			dotProduct.x = int(dot(float3(span.rgb), float3(pixel.rgb - endPoint.value[0].rgb)));
			color_index = (span_norm_sqr.x <= 0 /*endPoint[0] == endPoint[1]*/ || dotProduct.x <= 0 /*pixel == endPoint[0]*/) ? 0
				: ((dotProduct.x < span_norm_sqr.x) ? aStep[indexPrec.x][uint(dotProduct.x * 63.49999 / span_norm_sqr.x)] : aStep[indexPrec.x][63]);
			dotProduct.y = int(dot(float(span.a), float(pixel.a - endPoint.value[0].a)));
			alpha_index = (span_norm_sqr.y <= 0 || dotProduct.y <= 0) ? 0
				: ((dotProduct.y < span_norm_sqr.y) ? aStep[indexPrec.y][uint(dotProduct.y * 63.49999 / span_norm_sqr.y)] : aStep[indexPrec.y][63]);

			// the same color_index and alpha_index should be used for reconstruction, so this should be left commented out
			/*if (index_selector)
			{
				swap(color_index, alpha_index);
			}*/

			pixel_r.rgb = ((64 - aWeight[indexPrec.x][color_index]) * endPoint.value[0].rgb +
				aWeight[indexPrec.x][color_index] * endPoint.value[1].rgb +
				32) >> 6;
			pixel_r.a = ((64 - aWeight[indexPrec.y][alpha_index]) * endPoint.value[0].a +
				aWeight[indexPrec.y][alpha_index] * endPoint.value[1].a +
				32) >> 6;

			Ensure_A_Is_Larger(pixel_r, pixel);
			pixel_r -= pixel;
			if (1 == rotation)
			{
				pixel_r.ra = pixel_r.ar;
			}
			else if (2 == rotation)
			{
				pixel_r.ga = pixel_r.ag;
			}
			else if (3 == rotation)
			{
				pixel_r.ba = pixel_r.ab;
			}
			error += ComputeError(pixel_r, pixel_r);
		}
	}
	else if (threadInBlock < 16) // Try mode 6 in threads 12..15, since in mode 4 5 6, only mode 6 has p bit
	{
		uint p = threadInBlock - 12;

		compress_endpoints6(endPoint, uint2(p >> 0, p >> 1) & 1);

		uint4 pixel = shared_temp[threadBase + 0].pixel;

		span = int4(endPoint.value[1] - endPoint.value[0]);
		span_norm_sqr.x = int(dot(float4(span), float4(span)));
		dotProduct.x = int(dot(float4(span), float4(pixel - endPoint.value[0])));
		if (span_norm_sqr.x > 0 && dotProduct.x >= 0 && uint(dotProduct.x * 63.49999) > uint(32 * span_norm_sqr.x))
		{
			span = -span;
			swap(endPoint.value[0], endPoint.value[1]);
		}

		error = 0;
		for (uint i = 0; i < 16; i++)
		{
			pixel = shared_temp[threadBase + i].pixel;

			dotProduct.x = int(dot(float4(span), float4(pixel - endPoint.value[0])));
			color_index = (span_norm_sqr.x <= 0 || dotProduct.x <= 0) ? 0
				: ((dotProduct.x < span_norm_sqr.x) ? aStep[0][uint(dotProduct.x * 63.49999 / span_norm_sqr.x)] : aStep[0][63]);

			pixel_r = ((64 - aWeight[0][color_index]) * endPoint.value[0]
				+ aWeight[0][color_index] * endPoint.value[1] + 32) >> 6;

			Ensure_A_Is_Larger(pixel_r, pixel);
			pixel_r -= pixel;
			error += ComputeError(pixel_r, pixel_r);
		}

		mode = 6;
		rotation = p;    // Borrow rotation for p
	}

	shared_temp[GI].error = error;
	shared_temp[GI].mode = mode;
	shared_temp[GI].index_selector = index_selector;
	shared_temp[GI].rotation = rotation;

#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif

	if (threadInBlock < 8)
	{
		if (shared_temp[GI].error > shared_temp[GI + 8].error)
		{
			shared_temp[GI].error = shared_temp[GI + 8].error;
			shared_temp[GI].mode = shared_temp[GI + 8].mode;
			shared_temp[GI].index_selector = shared_temp[GI + 8].index_selector;
			shared_temp[GI].rotation = shared_temp[GI + 8].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 4)
	{
		if (shared_temp[GI].error > shared_temp[GI + 4].error)
		{
			shared_temp[GI].error = shared_temp[GI + 4].error;
			shared_temp[GI].mode = shared_temp[GI + 4].mode;
			shared_temp[GI].index_selector = shared_temp[GI + 4].index_selector;
			shared_temp[GI].rotation = shared_temp[GI + 4].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 2)
	{
		if (shared_temp[GI].error > shared_temp[GI + 2].error)
		{
			shared_temp[GI].error = shared_temp[GI + 2].error;
			shared_temp[GI].mode = shared_temp[GI + 2].mode;
			shared_temp[GI].index_selector = shared_temp[GI + 2].index_selector;
			shared_temp[GI].rotation = shared_temp[GI + 2].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 1)
	{
		if (shared_temp[GI].error > shared_temp[GI + 1].error)
		{
			shared_temp[GI].error = shared_temp[GI + 1].error;
			shared_temp[GI].mode = shared_temp[GI + 1].mode;
			shared_temp[GI].index_selector = shared_temp[GI + 1].index_selector;
			shared_temp[GI].rotation = shared_temp[GI + 1].rotation;
		}

		g_OutBuff[blockID] = uint4(shared_temp[GI].error, (shared_temp[GI].index_selector << 31) | shared_temp[GI].mode,
			0, shared_temp[GI].rotation); // rotation is indeed rotation for mode 4 5. for mode 6, rotation is p bit
	}
}

//--------------------------------------------------------------------------------------
// BC7 - Try Modes 1, 3, 7
//--------------------------------------------------------------------------------------
CS_LAYOUT(THREAD_GROUP_SIZE, 1, 1)
shader void CS_BC7TryMode137(uint GI : SV_GroupIndex, uint3 groupID : SV_GroupID) // mode 1 3 7 all have 2 subsets per block
{
	const uint MAX_USED_THREAD = 64;
	uint BLOCK_IN_GROUP = THREAD_GROUP_SIZE / MAX_USED_THREAD;
	uint blockInGroup = GI / MAX_USED_THREAD;
	uint blockID = g_start_block_id + groupID.x * BLOCK_IN_GROUP + blockInGroup;
	uint threadBase = blockInGroup * MAX_USED_THREAD;
	uint threadInBlock = GI - threadBase;

	uint block_y = blockID / g_num_block_x;
	uint block_x = blockID - block_y * g_num_block_x;
	uint base_x = block_x * BLOCK_SIZE_X;
	uint base_y = block_y * BLOCK_SIZE_Y;

	if (threadInBlock < 16)
	{
		shared_temp[GI].pixel = clamp(uint4(g_Input.Load(uint3(base_x + threadInBlock % 4, base_y + threadInBlock / 4, 0)) * 255), 0, 255);
	}
	GroupMemoryBarrierWithGroupSync();

	shared_temp[GI].error = 0xFFFFFFFF;

	uint4 pixel_r;
	Endpoint endPoint[2];        // endPoint[0..1 for subset id][0..1 for low and high in the subset]
	Endpoint endPointBackup[2];
	uint color_index;
	if (threadInBlock < 64)
	{
		uint partition_ = threadInBlock;

		endPoint[0].value[0] = uint4(MAX_UINT, MAX_UINT, MAX_UINT, MAX_UINT);
		endPoint[0].value[1] = uint4(MIN_UINT, MIN_UINT, MIN_UINT, MIN_UINT);
		endPoint[1].value[0] = uint4(MAX_UINT, MAX_UINT, MAX_UINT, MAX_UINT);
		endPoint[1].value[1] = uint4(MIN_UINT, MIN_UINT, MIN_UINT, MIN_UINT);
		uint bits = candidateSectionBit[partition_];
		for (uint i = 0; i < 16; i++)
		{
			uint4 pixel = shared_temp[threadBase + i].pixel;
			if (((bits >> i) & 0x01) == 1)
			{
				endPoint[1].value[0] = min(endPoint[1].value[0], pixel);
				endPoint[1].value[1] = max(endPoint[1].value[1], pixel);
			}
			else
			{
				endPoint[0].value[0] = min(endPoint[0].value[0], pixel);
				endPoint[0].value[1] = max(endPoint[0].value[1], pixel);
			}
		}

		endPointBackup[0] = endPoint[0];
		endPointBackup[1] = endPoint[1];

		uint max_p;
		if (1 == g_mode_id)
		{
			// in mode 1, there is only one p bit per subset
			max_p = 2;
		}
		else
		{
			// in mode 3 7, there are two p bits per subset, one for each end point
			max_p = 4;
		}

		uint final_p[2] = { 0, 0 };
		uint error[2] = { MAX_UINT, MAX_UINT };
		for (uint p = 0; p < max_p; p++)
		{
			endPoint[0] = endPointBackup[0];
			endPoint[1] = endPointBackup[1];

			for (uint i = 0; i < 2; i++) // loop through 2 subsets
			{
				if (g_mode_id == 1)
				{
					compress_endpoints1(endPoint[i], uint2(p, p));
				}
				else if (g_mode_id == 3)
				{
					compress_endpoints3(endPoint[i], uint2(p, p >> 1) & 1);
				}
				else if (g_mode_id == 7)
				{
					compress_endpoints7(endPoint[i], uint2(p, p >> 1) & 1);
				}
			}

			int4 span[2];
			span[0] = int4(endPoint[0].value[1] - endPoint[0].value[0]);
			span[1] = int4(endPoint[1].value[1] - endPoint[1].value[0]);

			if (g_mode_id != 7)
			{
				span[0].w = span[1].w = 0;
			}

			int span_norm_sqr[2];
			span_norm_sqr[0] = int(dot(float4(span[0]), float4(span[0])));
			span_norm_sqr[1] = int(dot(float4(span[1]), float4(span[1])));

			// TODO: again, this shouldn't be necessary here in error calculation
			int dotProduct = int(dot(float4(span[0]), float4(shared_temp[threadBase + 0].pixel - endPoint[0].value[0])));
			if (span_norm_sqr[0] > 0 && dotProduct > 0 && uint(dotProduct * 63.49999) > uint(32 * span_norm_sqr[0]))
			{
				span[0] = -span[0];
				swap(endPoint[0].value[0], endPoint[0].value[1]);
			}
			dotProduct = int(dot(float4(span[1]), float4(shared_temp[threadBase + candidateFixUpIndex1D[partition_].x].pixel - endPoint[1].value[0])));
			if (span_norm_sqr[1] > 0 && dotProduct > 0 && uint(dotProduct * 63.49999) > uint(32 * span_norm_sqr[1]))
			{
				span[1] = -span[1];
				swap(endPoint[1].value[0], endPoint[1].value[1]);
			}

			uint step_selector;
			if (g_mode_id != 1)
			{
				step_selector = 2;  // mode 3 7 have 2 bit index
			}
			else
			{
				step_selector = 1;  // mode 1 has 3 bit index
			}

			uint p_error[2] = { 0, 0 };
			for (uint i = 0; i < 16; i++)
			{
				uint subset_index = (bits >> i) & 0x01;

				if (subset_index == 1)
				{
					dotProduct = int(dot(float4(span[1]), float4(shared_temp[threadBase + i].pixel - endPoint[1].value[0])));
					color_index = (span_norm_sqr[1] <= 0 || dotProduct <= 0) ? 0
						: ((dotProduct < span_norm_sqr[1]) ? aStep[step_selector][uint(dotProduct * 63.49999 / span_norm_sqr[1])] : aStep[step_selector][63]);
				}
				else
				{
					dotProduct = int(dot(float4(span[0]), float4(shared_temp[threadBase + i].pixel - endPoint[0].value[0])));
					color_index = (span_norm_sqr[0] <= 0 || dotProduct <= 0) ? 0
						: ((dotProduct < span_norm_sqr[0]) ? aStep[step_selector][uint(dotProduct * 63.49999 / span_norm_sqr[0])] : aStep[step_selector][63]);
				}

				pixel_r = ((64 - aWeight[step_selector][color_index]) * endPoint[subset_index].value[0]
					+ aWeight[step_selector][color_index] * endPoint[subset_index].value[1] + 32) >> 6;
				if (g_mode_id != 7)
				{
					pixel_r.a = 255;
				}

				uint4 pixel = shared_temp[threadBase + i].pixel;
				Ensure_A_Is_Larger(pixel_r, pixel);
				pixel_r -= pixel;
				uint pixel_error = ComputeError(pixel_r, pixel_r);
				if (subset_index == 1)
					p_error[1] += pixel_error;
				else
					p_error[0] += pixel_error;
			}

			for (uint i = 0; i < 2; i++)
			{
				if (p_error[i] < error[i])
				{
					error[i] = p_error[i];
					final_p[i] = p;
				}
			}
		}

		shared_temp[GI].error = error[0] + error[1];
		shared_temp[GI].mode = g_mode_id;
		shared_temp[GI].partition_ = partition_;

		// mode 1 3 7 don't have rotation, we use rotation for p bits
		if (g_mode_id == 1)
			shared_temp[GI].rotation = (final_p[1] << 1) | final_p[0];
		else
			shared_temp[GI].rotation = (final_p[1] << 2) | final_p[0];
	}
	GroupMemoryBarrierWithGroupSync();

	if (threadInBlock < 32)
	{
		if (shared_temp[GI].error > shared_temp[GI + 32].error)
		{
			shared_temp[GI].error = shared_temp[GI + 32].error;
			shared_temp[GI].mode = shared_temp[GI + 32].mode;
			shared_temp[GI].partition_ = shared_temp[GI + 32].partition_;
			shared_temp[GI].rotation = shared_temp[GI + 32].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 16)
	{
		if (shared_temp[GI].error > shared_temp[GI + 16].error)
		{
			shared_temp[GI].error = shared_temp[GI + 16].error;
			shared_temp[GI].mode = shared_temp[GI + 16].mode;
			shared_temp[GI].partition_ = shared_temp[GI + 16].partition_;
			shared_temp[GI].rotation = shared_temp[GI + 16].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 8)
	{
		if (shared_temp[GI].error > shared_temp[GI + 8].error)
		{
			shared_temp[GI].error = shared_temp[GI + 8].error;
			shared_temp[GI].mode = shared_temp[GI + 8].mode;
			shared_temp[GI].partition_ = shared_temp[GI + 8].partition_;
			shared_temp[GI].rotation = shared_temp[GI + 8].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 4)
	{
		if (shared_temp[GI].error > shared_temp[GI + 4].error)
		{
			shared_temp[GI].error = shared_temp[GI + 4].error;
			shared_temp[GI].mode = shared_temp[GI + 4].mode;
			shared_temp[GI].partition_ = shared_temp[GI + 4].partition_;
			shared_temp[GI].rotation = shared_temp[GI + 4].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 2)
	{
		if (shared_temp[GI].error > shared_temp[GI + 2].error)
		{
			shared_temp[GI].error = shared_temp[GI + 2].error;
			shared_temp[GI].mode = shared_temp[GI + 2].mode;
			shared_temp[GI].partition_ = shared_temp[GI + 2].partition_;
			shared_temp[GI].rotation = shared_temp[GI + 2].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 1)
	{
		if (shared_temp[GI].error > shared_temp[GI + 1].error)
		{
			shared_temp[GI].error = shared_temp[GI + 1].error;
			shared_temp[GI].mode = shared_temp[GI + 1].mode;
			shared_temp[GI].partition_ = shared_temp[GI + 1].partition_;
			shared_temp[GI].rotation = shared_temp[GI + 1].rotation;
		}

		if (g_InBuff[blockID].x > shared_temp[GI].error)
		{
			g_OutBuff[blockID] = uint4(shared_temp[GI].error, shared_temp[GI].mode, shared_temp[GI].partition_, shared_temp[GI].rotation); // mode 1 3 7 don't have rotation, we use rotation for p bits
		}
		else
		{
			g_OutBuff[blockID] = g_InBuff[blockID];
		}
	}
}

//--------------------------------------------------------------------------------------
// BC7 - Try Modes 0, 2
//--------------------------------------------------------------------------------------
CS_LAYOUT(THREAD_GROUP_SIZE, 1, 1)
shader void CS_BC7TryMode02(uint GI : SV_GroupIndex, uint3 groupID : SV_GroupID) // mode 0 2 have 3 subsets per block
{
	const uint MAX_USED_THREAD = 64;
	uint BLOCK_IN_GROUP = THREAD_GROUP_SIZE / MAX_USED_THREAD;
	uint blockInGroup = GI / MAX_USED_THREAD;
	uint blockID = g_start_block_id + groupID.x * BLOCK_IN_GROUP + blockInGroup;
	uint threadBase = blockInGroup * MAX_USED_THREAD;
	uint threadInBlock = GI - threadBase;

	uint block_y = blockID / g_num_block_x;
	uint block_x = blockID - block_y * g_num_block_x;
	uint base_x = block_x * BLOCK_SIZE_X;
	uint base_y = block_y * BLOCK_SIZE_Y;

	if (threadInBlock < 16)
	{
		shared_temp[GI].pixel = clamp(uint4(g_Input.Load(uint3(base_x + threadInBlock % 4, base_y + threadInBlock / 4, 0)) * 255), 0, 255);
	}
	GroupMemoryBarrierWithGroupSync();

	shared_temp[GI].error = 0xFFFFFFFF;

	uint num_partitions;
	if (0 == g_mode_id)
	{
		num_partitions = 16;
	}
	else
	{
		num_partitions = 64;
	}

	uint4 pixel_r;
	Endpoint endPoint[3];        // endPoint[0..1 for subset id][0..1 for low and high in the subset]
	Endpoint endPointBackup[3];
	uint color_index[16];
	if (threadInBlock < num_partitions)
	{
		uint partition_ = threadInBlock + 64;

		endPoint[0].value[0] = uint4(MAX_UINT, MAX_UINT, MAX_UINT, MAX_UINT);
		endPoint[0].value[1] = uint4(MIN_UINT, MIN_UINT, MIN_UINT, MIN_UINT);
		endPoint[1].value[0] = uint4(MAX_UINT, MAX_UINT, MAX_UINT, MAX_UINT);
		endPoint[1].value[1] = uint4(MIN_UINT, MIN_UINT, MIN_UINT, MIN_UINT);
		endPoint[2].value[0] = uint4(MAX_UINT, MAX_UINT, MAX_UINT, MAX_UINT);
		endPoint[2].value[1] = uint4(MIN_UINT, MIN_UINT, MIN_UINT, MIN_UINT);
		uint bits2 = candidateSectionBit2[partition_ - 64];
		for (uint i = 0; i < 16; i++)
		{
			uint4 pixel = shared_temp[threadBase + i].pixel;
			uint subset_index = (bits2 >> (i * 2)) & 0x03;
			if (subset_index == 2)
			{
				endPoint[2].value[0] = min(endPoint[2].value[0], pixel);
				endPoint[2].value[1] = max(endPoint[2].value[1], pixel);
			}
			else if (subset_index == 1)
			{
				endPoint[1].value[0] = min(endPoint[1].value[0], pixel);
				endPoint[1].value[1] = max(endPoint[1].value[1], pixel);
			}
			else
			{
				endPoint[0].value[0] = min(endPoint[0].value[0], pixel);
				endPoint[0].value[1] = max(endPoint[0].value[1], pixel);
			}
		}

		endPointBackup[0] = endPoint[0];
		endPointBackup[1] = endPoint[1];
		endPointBackup[2] = endPoint[2];

		uint max_p;
		if (0 == g_mode_id)
		{
			max_p = 4;
		}
		else
		{
			max_p = 1;
		}

		uint final_p[3] = { 0, 0, 0 };
		uint error[3] = { MAX_UINT, MAX_UINT, MAX_UINT };
		for (uint p = 0; p < max_p; p++)
		{
			endPoint[0] = endPointBackup[0];
			endPoint[1] = endPointBackup[1];
			endPoint[2] = endPointBackup[2];

			for (uint i = 0; i < 3; i++)
			{
				if (0 == g_mode_id)
				{
					compress_endpoints0(endPoint[i], uint2(p, p >> 1) & 1);
				}
				else
				{
					compress_endpoints2(endPoint[i]);
				}
			}

			uint step_selector = 1 + uint(2 == g_mode_id);

			int4 span[3];
			span[0] = int4(endPoint[0].value[1] - endPoint[0].value[0]);
			span[1] = int4(endPoint[1].value[1] - endPoint[1].value[0]);
			span[2] = int4(endPoint[2].value[1] - endPoint[2].value[0]);
			span[0].w = span[1].w = span[2].w = 0;
			int span_norm_sqr[3];
			span_norm_sqr[0] = int(dot(float4(span[0]), float4(span[0])));
			span_norm_sqr[1] = int(dot(float4(span[1]), float4(span[1])));
			span_norm_sqr[2] = int(dot(float4(span[2]), float4(span[2])));

			// TODO: again, this shouldn't be necessary here in error calculation
			uint ci[3] = { 0, candidateFixUpIndex1D[partition_].x, candidateFixUpIndex1D[partition_].y };
			for (uint i = 0; i < 3; i++)
			{
				int dotProduct = int(dot(float4(span[i]), float4(shared_temp[threadBase + ci[i]].pixel - endPoint[i].value[0])));
				if (span_norm_sqr[i] > 0 && dotProduct > 0 && uint(dotProduct * 63.49999) > uint(32 * span_norm_sqr[i]))
				{
					span[i] = -span[i];
					swap(endPoint[i].value[0], endPoint[i].value[1]);
				}
			}

			uint p_error[3] = { 0, 0, 0 };
			for (uint i = 0; i < 16; i++)
			{
				uint subset_index = (bits2 >> (i * 2)) & 0x03;
				if (subset_index == 2)
				{
					int dotProduct = int(dot(float4(span[2]), float4(shared_temp[threadBase + i].pixel - endPoint[2].value[0])));
					color_index[i] = (span_norm_sqr[2] <= 0 || dotProduct <= 0) ? 0
						: ((dotProduct < span_norm_sqr[2]) ? aStep[step_selector][uint(dotProduct * 63.49999 / span_norm_sqr[2])] : aStep[step_selector][63]);
				}
				else if (subset_index == 1)
				{
					int dotProduct = int(dot(float4(span[1]), float4(shared_temp[threadBase + i].pixel - endPoint[1].value[0])));
					color_index[i] = (span_norm_sqr[1] <= 0 || dotProduct <= 0) ? 0
						: ((dotProduct < span_norm_sqr[1]) ? aStep[step_selector][uint(dotProduct * 63.49999 / span_norm_sqr[1])] : aStep[step_selector][63]);
				}
				else
				{
					int dotProduct = int(dot(float4(span[0]), float4(shared_temp[threadBase + i].pixel - endPoint[0].value[0])));
					color_index[i] = (span_norm_sqr[0] <= 0 || dotProduct <= 0) ? 0
						: ((dotProduct < span_norm_sqr[0]) ? aStep[step_selector][uint(dotProduct * 63.49999 / span_norm_sqr[0])] : aStep[step_selector][63]);
				}

				pixel_r = ((64 - aWeight[step_selector][color_index[i]]) * endPoint[subset_index].value[0]
					+ aWeight[step_selector][color_index[i]] * endPoint[subset_index].value[1] + 32) >> 6;
				pixel_r.a = 255;

				uint4 pixel = shared_temp[threadBase + i].pixel;
				Ensure_A_Is_Larger(pixel_r, pixel);
				pixel_r -= pixel;

				uint pixel_error = ComputeError(pixel_r, pixel_r);

				if (subset_index == 2)
					p_error[2] += pixel_error;
				else if (subset_index == 1)
					p_error[1] += pixel_error;
				else
					p_error[0] += pixel_error;
			}

			for (uint i = 0; i < 3; i++)
			{
				if (p_error[i] < error[i])
				{
					error[i] = p_error[i];
					final_p[i] = p;    // Borrow rotation for p
				}
			}
		}

		shared_temp[GI].error = error[0] + error[1] + error[2];
		shared_temp[GI].partition_ = partition_;
		shared_temp[GI].rotation = (final_p[2] << 4) | (final_p[1] << 2) | final_p[0];
	}
	GroupMemoryBarrierWithGroupSync();

	if (threadInBlock < 32)
	{
		if (shared_temp[GI].error > shared_temp[GI + 32].error)
		{
			shared_temp[GI].error = shared_temp[GI + 32].error;
			shared_temp[GI].partition_ = shared_temp[GI + 32].partition_;
			shared_temp[GI].rotation = shared_temp[GI + 32].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 16)
	{
		if (shared_temp[GI].error > shared_temp[GI + 16].error)
		{
			shared_temp[GI].error = shared_temp[GI + 16].error;
			shared_temp[GI].partition_ = shared_temp[GI + 16].partition_;
			shared_temp[GI].rotation = shared_temp[GI + 16].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 8)
	{
		if (shared_temp[GI].error > shared_temp[GI + 8].error)
		{
			shared_temp[GI].error = shared_temp[GI + 8].error;
			shared_temp[GI].partition_ = shared_temp[GI + 8].partition_;
			shared_temp[GI].rotation = shared_temp[GI + 8].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 4)
	{
		if (shared_temp[GI].error > shared_temp[GI + 4].error)
		{
			shared_temp[GI].error = shared_temp[GI + 4].error;
			shared_temp[GI].partition_ = shared_temp[GI + 4].partition_;
			shared_temp[GI].rotation = shared_temp[GI + 4].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 2)
	{
		if (shared_temp[GI].error > shared_temp[GI + 2].error)
		{
			shared_temp[GI].error = shared_temp[GI + 2].error;
			shared_temp[GI].partition_ = shared_temp[GI + 2].partition_;
			shared_temp[GI].rotation = shared_temp[GI + 2].rotation;
		}
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif
	if (threadInBlock < 1)
	{
		if (shared_temp[GI].error > shared_temp[GI + 1].error)
		{
			shared_temp[GI].error = shared_temp[GI + 1].error;
			shared_temp[GI].partition_ = shared_temp[GI + 1].partition_;
			shared_temp[GI].rotation = shared_temp[GI + 1].rotation;
		}

		if (g_InBuff[blockID].x > shared_temp[GI].error)
		{
			g_OutBuff[blockID] = uint4(shared_temp[GI].error, g_mode_id, shared_temp[GI].partition_, shared_temp[GI].rotation); // rotation is actually p bit for mode 0. for mode 2, rotation is always 0
		}
		else
		{
			g_OutBuff[blockID] = g_InBuff[blockID];
		}
	}
}

//--------------------------------------------------------------------------------------
// BC7 - All modes
//--------------------------------------------------------------------------------------
CS_LAYOUT(THREAD_GROUP_SIZE, 1, 1)
shader void CS_BC7EncodeBlock(uint GI : SV_GroupIndex, uint3 groupID : SV_GroupID)
{
	const uint MAX_USED_THREAD = 16;
	uint BLOCK_IN_GROUP = THREAD_GROUP_SIZE / MAX_USED_THREAD;
	uint blockInGroup = GI / MAX_USED_THREAD;
	uint blockID = g_start_block_id + groupID.x * BLOCK_IN_GROUP + blockInGroup;
	uint threadBase = blockInGroup * MAX_USED_THREAD;
	uint threadInBlock = GI - threadBase;

#ifndef REF_DEVICE
	if (blockID >= g_num_total_blocks)
	{
		return;
	}
#endif

	uint block_y = blockID / g_num_block_x;
	uint block_x = blockID - block_y * g_num_block_x;
	uint base_x = block_x * BLOCK_SIZE_X;
	uint base_y = block_y * BLOCK_SIZE_Y;

	uint mode = g_InBuff[blockID].y & 0x7FFFFFFF;
	uint partition_ = g_InBuff[blockID].z;
	uint index_selector = (g_InBuff[blockID].y >> 31) & 1;
	uint rotation = g_InBuff[blockID].w;

	if (threadInBlock < 16)
	{
		uint4 pixel = clamp(uint4(g_Input.Load(uint3(base_x + threadInBlock % 4, base_y + threadInBlock / 4, 0)) * 255), 0, 255);

		if ((4 == mode) || (5 == mode))
		{
			if (1 == rotation)
			{
				pixel.ra = pixel.ar;
			}
			else if (2 == rotation)
			{
				pixel.ga = pixel.ag;
			}
			else if (3 == rotation)
			{
				pixel.ba = pixel.ab;
			}
		}

		shared_temp[GI].pixel = pixel;
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif

	uint bits = candidateSectionBit[partition_];
	uint bits2 = candidateSectionBit2[partition_ - 64];

	Endpoint ep;
	ep.value[0] = uint4(MAX_UINT, MAX_UINT, MAX_UINT, MAX_UINT);
	ep.value[1] = uint4(MIN_UINT, MIN_UINT, MIN_UINT, MIN_UINT);
	Endpoint ep_quantized;
	
	for (int ii = 2; ii >= 0; --ii)
	{
		if (threadInBlock < 16)
		{
			Endpoint ep;
			ep.value[0] = uint4(MAX_UINT, MAX_UINT, MAX_UINT, MAX_UINT);
			ep.value[1] = uint4(MIN_UINT, MIN_UINT, MIN_UINT, MIN_UINT);

			uint4 pixel = shared_temp[GI].pixel;

			uint subset_index = (bits >> threadInBlock) & 0x01;
			uint subset_index2 = (bits2 >> (threadInBlock * 2)) & 0x03;
			if (0 == ii)
			{
				if ((0 == mode) || (2 == mode))
				{
					if (0 == subset_index2)
					{
						ep.value[0] = ep.value[1] = pixel;
					}
				}
				else if ((1 == mode) || (3 == mode) || (7 == mode))
				{
					if (0 == subset_index)
					{
						ep.value[0] = ep.value[1] = pixel;
					}
				}
				else if ((4 == mode) || (5 == mode) || (6 == mode))
				{
					ep.value[0] = ep.value[1] = pixel;
				}
			}
			else if (1 == ii)
			{
				if ((0 == mode) || (2 == mode))
				{
					if (1 == subset_index2)
					{
						ep.value[0] = ep.value[1] = pixel;
					}
				}
				else if ((1 == mode) || (3 == mode) || (7 == mode))
				{
					if (1 == subset_index)
					{
						ep.value[0] = ep.value[1] = pixel;
					}
				}
			}
			else
			{
				if ((0 == mode) || (2 == mode))
				{
					if (2 == subset_index2)
					{
						ep.value[0] = ep.value[1] = pixel;
					}
				}
			}

			shared_temp[GI].endPoint_low = ep.value[0];
			shared_temp[GI].endPoint_high = ep.value[1];
		}
#ifdef REF_DEVICE
		GroupMemoryBarrierWithGroupSync();
#endif

		if (threadInBlock < 8)
		{
			shared_temp[GI].endPoint_low = min(shared_temp[GI].endPoint_low, shared_temp[GI + 8].endPoint_low);
			shared_temp[GI].endPoint_high = max(shared_temp[GI].endPoint_high, shared_temp[GI + 8].endPoint_high);
		}
#ifdef REF_DEVICE
		GroupMemoryBarrierWithGroupSync();
#endif
		if (threadInBlock < 4)
		{
			shared_temp[GI].endPoint_low = min(shared_temp[GI].endPoint_low, shared_temp[GI + 4].endPoint_low);
			shared_temp[GI].endPoint_high = max(shared_temp[GI].endPoint_high, shared_temp[GI + 4].endPoint_high);
		}
#ifdef REF_DEVICE
		GroupMemoryBarrierWithGroupSync();
#endif
		if (threadInBlock < 2)
		{
			shared_temp[GI].endPoint_low = min(shared_temp[GI].endPoint_low, shared_temp[GI + 2].endPoint_low);
			shared_temp[GI].endPoint_high = max(shared_temp[GI].endPoint_high, shared_temp[GI + 2].endPoint_high);
		}
#ifdef REF_DEVICE
		GroupMemoryBarrierWithGroupSync();
#endif
		if (threadInBlock < 1)
		{
			shared_temp[GI].endPoint_low = min(shared_temp[GI].endPoint_low, shared_temp[GI + 1].endPoint_low);
			shared_temp[GI].endPoint_high = max(shared_temp[GI].endPoint_high, shared_temp[GI + 1].endPoint_high);
		}
#ifdef REF_DEVICE
		GroupMemoryBarrierWithGroupSync();
#endif

		if (ii == int(threadInBlock))
		{
			ep.value[0] = shared_temp[threadBase].endPoint_low;
			ep.value[1] = shared_temp[threadBase].endPoint_high;
		}
	}

	if (threadInBlock < 3)
	{
		uint2 P;
		if (1 == mode)
		{
			P = uint2((rotation >> threadInBlock) & 1, (rotation >> threadInBlock) & 1);
		}
		else
		{
			P = uint2(rotation >> (threadInBlock * 2 + 0), rotation >> (threadInBlock * 2 + 1)) & 1;
		}

		if (0 == mode)
		{
			ep_quantized = compress_endpoints0(ep, P);
		}
		else if (1 == mode)
		{
			ep_quantized = compress_endpoints1(ep, P);
		}
		else if (2 == mode)
		{
			ep_quantized = compress_endpoints2(ep);
		}
		else if (3 == mode)
		{
			ep_quantized = compress_endpoints3(ep, P);
		}
		else if (4 == mode)
		{
			ep_quantized = compress_endpoints4(ep);
		}
		else if (5 == mode)
		{
			ep_quantized = compress_endpoints5(ep);
		}
		else if (6 == mode)
		{
			ep_quantized = compress_endpoints6(ep, P);
		}
		else //if (7 == mode)
		{
			ep_quantized = compress_endpoints7(ep, P);
		}

		int4 span = int4(ep.value[1] - ep.value[0]);
		if (mode < 4)
		{
			span.w = 0;
		}

		if ((4 == mode) || (5 == mode))
		{
			if (0 == threadInBlock)
			{
				int2 span_norm_sqr = int2(dot(float3(span.rgb), float3(span.rgb)), span.a * span.a);
				int2 dotProduct = int2(dot(float3(span.rgb), float3(shared_temp[threadBase + 0].pixel.rgb - ep.value[0].rgb)), span.a * (shared_temp[threadBase + 0].pixel.a - ep.value[0].a));
				if (span_norm_sqr.x > 0 && dotProduct.x > 0 && uint(dotProduct.x * 63.49999) > uint(32 * span_norm_sqr.x))
				{
					swap(ep.value[0].rgb, ep.value[1].rgb);
					swap(ep_quantized.value[0].rgb, ep_quantized.value[1].rgb);
				}
				if (span_norm_sqr.y > 0 && dotProduct.y > 0 && uint(dotProduct.y * 63.49999) > uint(32 * span_norm_sqr.y))
				{
					swap(ep.value[0].a, ep.value[1].a);
					swap(ep_quantized.value[0].a, ep_quantized.value[1].a);
				}
			}
		}
		else //if ((0 == mode) || (2 == mode) || (1 == mode) || (3 == mode) || (7 == mode) || (6 == mode))
		{
			int p;
			if (0 == threadInBlock)
			{
				p = 0;
			}
			else if (1 == threadInBlock)
			{
				p = int(candidateFixUpIndex1D[partition_].x);
			}
			else //if (2 == threadInBlock)
			{
				p = int(candidateFixUpIndex1D[partition_].y);
			}

			int span_norm_sqr = int(dot(float4(span), float4(span)));
			int dotProduct = int(dot(float4(span), float4(shared_temp[threadBase + p].pixel - ep.value[0])));
			if (span_norm_sqr > 0 && dotProduct > 0 && uint(dotProduct * 63.49999) > uint(32 * span_norm_sqr))
			{
				swap(ep.value[0], ep.value[1]);
				swap(ep_quantized.value[0], ep_quantized.value[1]);
			}
		}

		shared_temp[GI].endPoint_low = ep.value[0];
		shared_temp[GI].endPoint_high = ep.value[1];
		shared_temp[GI].endPoint_low_quantized = ep_quantized.value[0];
		shared_temp[GI].endPoint_high_quantized = ep_quantized.value[1];
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif

	if (threadInBlock < 16)
	{
		uint color_index = 0;
		uint alpha_index = 0;

		Endpoint ep;

		uint2 indexPrec;
		if ((0 == mode) || (1 == mode))
		{
			indexPrec = uint2(1, 1);
		}
		else if (6 == mode)
		{
			indexPrec = uint2(0, 0);
		}
		else if (4 == mode)
		{
			if (0 == index_selector)
			{
				indexPrec = uint2(2, 1);
			}
			else
			{
				indexPrec = uint2(1, 2);
			}
		}
		else
		{
			indexPrec = uint2(2, 2);
		}

		int subset_index;
		if ((0 == mode) || (2 == mode))
		{
			subset_index = int((bits2 >> (threadInBlock * 2)) & 0x03);
		}
		else if ((1 == mode) || (3 == mode) || (7 == mode))
		{
			subset_index = int((bits >> threadInBlock) & 0x01);
		}
		else
		{
			subset_index = 0;
		}

		ep.value[0] = shared_temp[threadBase + subset_index].endPoint_low;
		ep.value[1] = shared_temp[threadBase + subset_index].endPoint_high;

		int4 span = int4(ep.value[1] - ep.value[0]);
		if (mode < 4)
		{
			span.w = 0;
		}

		if ((4 == mode) || (5 == mode))
		{
			int2 span_norm_sqr;
			span_norm_sqr.x = int(dot(float3(span.rgb), float3(span.rgb)));
			span_norm_sqr.y = span.a * span.a;

			int dotProduct = int(dot(float3(span.rgb), float3(shared_temp[threadBase + threadInBlock].pixel.rgb - ep.value[0].rgb)));
			color_index = (span_norm_sqr.x <= 0 || dotProduct <= 0) ? 0
				: ((dotProduct < span_norm_sqr.x) ? aStep[indexPrec.x][uint(dotProduct * 63.49999 / span_norm_sqr.x)] : aStep[indexPrec.x][63]);
			dotProduct = int(dot(float(span.a), float(shared_temp[threadBase + threadInBlock].pixel.a - ep.value[0].a)));
			alpha_index = (span_norm_sqr.y <= 0 || dotProduct <= 0) ? 0
				: ((dotProduct < span_norm_sqr.y) ? aStep[indexPrec.y][uint(dotProduct * 63.49999 / span_norm_sqr.y)] : aStep[indexPrec.y][63]);

			if (index_selector > 0)
			{
				swap(color_index, alpha_index);
			}
		}
		else
		{
			int span_norm_sqr = int(dot(float4(span), float4(span)));

			int dotProduct = int(dot(float4(span), float4(shared_temp[threadBase + threadInBlock].pixel - ep.value[0])));
			color_index = (span_norm_sqr <= 0 || dotProduct <= 0) ? 0
				: ((dotProduct < span_norm_sqr) ? aStep[indexPrec.x][uint(dotProduct * 63.49999 / span_norm_sqr)] : aStep[indexPrec.x][63]);
		}

		shared_temp[GI].error = color_index;
		shared_temp[GI].mode = alpha_index;
	}
#ifdef REF_DEVICE
	GroupMemoryBarrierWithGroupSync();
#endif

	if (0 == threadInBlock)
	{
		uint4 block;
		if (0 == mode)
		{
			block_package0(block, partition_, threadBase);
		}
		else if (1 == mode)
		{
			block_package1(block, partition_, threadBase);
		}
		else if (2 == mode)
		{
			block_package2(block, partition_, threadBase);
		}
		else if (3 == mode)
		{
			block_package3(block, partition_, threadBase);
		}
		else if (4 == mode)
		{
			block_package4(block, rotation, index_selector, threadBase);
		}
		else if (5 == mode)
		{
			block_package5(block, rotation, threadBase);
		}
		else if (6 == mode)
		{
			block_package6(block, threadBase);
		}
		else //if (7 == mode)
		{
			block_package7(block, partition_, threadBase);
		}

		g_OutBuff[blockID] = block;
	}
}

//--------------------------------------------------------------------------------------
// Techniques
//--------------------------------------------------------------------------------------

fxgroup texture_compression
{
	technique bc1
	{
		pass p0
		{
			SetComputeShader(CompileShader(cs_5_0, CS_BC1Compress()));
		}
	}
	technique bc3
	{
		pass p0
		{
			SetComputeShader(CompileShader(cs_5_0, CS_BC3Compress()));
		}
	}
	technique bc4
	{
		pass p0
		{
			SetComputeShader(CompileShader(cs_5_0, CS_BC4Compress()));
		}
	}
	technique bc5
	{
		pass p0
		{
			SetComputeShader(CompileShader(cs_5_0, CS_BC5Compress()));
		}
	}	
	technique bc7
	{
		pass try456
		{
			SetComputeShader(CompileShader(cs_5_0, CS_BC7TryMode456()));
		}
		pass try137
		{
			SetComputeShader(CompileShader(cs_5_0, CS_BC7TryMode137()));
		}
		pass try02
		{
			SetComputeShader(CompileShader(cs_5_0, CS_BC7TryMode02()));
		}
		pass encode
		{
			SetComputeShader(CompileShader(cs_5_0, CS_BC7EncodeBlock()));
		}
	}
}