//  Copyright (c) Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"
#include "common.sl"
#include "render_states.sl"
#include "depth.sl"
#include "colour_packing.sl"
#include "debug_constants.sl"
#include "sampler_states.sl"
#include "quaternion.sl"
#include "cubemap_matrices.sl"
#include "random.sl"

uniform Texture2D imageTexture SIMUL_TEXTURE_REGISTER(0);
uniform Texture2DArray imageTextureArray SIMUL_TEXTURE_REGISTER(0);
uniform Texture2DMS<vec4> imageTextureMS SIMUL_TEXTURE_REGISTER(1);
uniform TextureCube cubeTexture SIMUL_TEXTURE_REGISTER(2);
uniform TextureCubeArray cubeTextureArray;
uniform TEXTURE2D_UINT imageTextureUint SIMUL_TEXTURE_REGISTER(3);

uniform RWTexture2D<vec4> FastClearTarget SIMUL_RWTEXTURE_REGISTER(0);
uniform RWTexture2DArray<vec4> FastClearTarget2DArray SIMUL_RWTEXTURE_REGISTER(0);
uniform RWTexture2DArray<uchar4> FastClearTarget2DArrayU8 SIMUL_RWTEXTURE_REGISTER(0);

uniform RWTexture3D<vec4> FastClearTarget3D SIMUL_RWTEXTURE_REGISTER(0);
uniform RWTexture3D<uchar4> FastClearTarget3DU8 SIMUL_RWTEXTURE_REGISTER(0);
uniform RWStructuredBuffer<vec4> textureQueryResults SIMUL_RWTEXTURE_REGISTER(0);

uniform Texture3D volumeTexture;

bool IsNaN(float x)
{
	return !(x < 0.f || x > 0.f || x == 0.f);
}
void DetectNaNs(vec2 texc, inout vec3 clr)
{
	if (IsNaN(clr.r) || IsNaN(clr.g) || IsNaN(clr.b))
	{
		vec3 rnd = PcgRand3(55 + int(debugTime * 135136 + 26432.11 * texc.x + 10024611.5 * texc.y));
		clr.rgb = rnd;
	}
}
void DetectNaNs(vec3 texc, inout vec3 clr)
{
	if (IsNaN(clr.r) || IsNaN(clr.g) || IsNaN(clr.b))
	{
		vec3 rnd = PcgRand3(55 + int(debugTime * 135136 + 26432.11 * texc.x + 10024611.5 * texc.y + 63241247.81 * texc.z));
		clr.rgb = rnd;
	}
}

#if 1
#define DETECT_NANS(x,y) DetectNaNs(x,y)
#else
#define DETECT_NANS(x,y)
#endif

struct a2v
{
	vec3 position	: POSITION;
	vec4 colour		: TEXCOORD0;
};

struct v2f
{
	vec4 hPosition	: SV_POSITION;
	vec4 colour		: TEXCOORD0;
};

shader posTexVertexOutput VS_Quad(idOnly id)
{
	return VS_ScreenQuad(id,rect);
}

shader v2f DebugVS(positionColourVertexInput IN)
{
	v2f OUT;
	vec3 pos		=IN.position.xyz;
	OUT.hPosition	=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
	OUT.colour		=IN.colour;
	return OUT;
}

shader v2f Debug2dVS(a2v IN)
{
	v2f OUT;
	OUT.hPosition	=vec4(rect.xy+rect.zw*IN.position.xy,0.0,1.0);
	OUT.colour		=IN.colour;
	return OUT;
}

shader v2f CircleVS(idOnly IN)
{
	v2f OUT;
	float angle		=2.0*3.1415926536*float(IN.vertex_id)/31.0;
	vec4 pos		=vec4(vec3(x_axis*cos(angle)+y_axis*sin(angle))+centre_position,1.0);
	OUT.hPosition	=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
	OUT.colour		=debugColour;
	return OUT;
}

shader v2f FilledCircleVS(idOnly IN)
{
	v2f OUT;
	int i			=int(IN.vertex_id/2);
	int j			=int(IN.vertex_id%uint(2));
	float angle		=2.0*3.1415926536*float(i)/31.0;
	vec4 pos		=vec4(vec3(x_axis*cos(angle)+y_axis*sin(angle))*j+centre_position,1.0);
	OUT.hPosition	=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
	OUT.colour		=debugColour;
	return OUT;
}

shader vec4 DebugPS(v2f IN) : SV_TARGET
{
	vec4 c		=IN.colour;
	return c;
}

shader vec4 DebugFP16PS(v2f IN) : SV_TARGET
{
	vec4 c = uint16_t(2) * f16vec4(IN.colour);
	return c;
}

vec4 ShowDepthCube(posTexVertexOutput IN,bool reverseDepth) 
{
	vec2 texc		=IN.texCoords.xy;
	float se		=texc.y*2.0-1.0;
	float ce		=cos(asin(se));
	float az		=texc.x*3.1415926536*2.0;
	float cs		=cos(az);
	float ss		=sin(az);
	vec3 view		=normalize(vec3(ce*ss,ce*cs,se));
	vec4 depth		=texture_cube(cubeTexture,view);

	DepthInterpretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=debugDepthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	vec4 dist		=depthToLinearDistance(depth,depthInterpretationStruct);
	if(texc.x+texc.y>1.0)
		dist.xy		=dist.zw;
	dist.z			=0;
	vec4 result		=vec4(pow(dist.xyz,vec3(0.44,0.44,0.44)),1.0);

	return result;
}

shader vec4 PS_ShowCubemap(posTexVertexOutput IN) : SV_TARGET
{
	vec2 texc		=IN.texCoords.xy;
	float se		=texc.y*2.0-1.0;
	float ce		=cos(asin(se));
	float az		=texc.x*3.1415926536*2.0;
	float cs		=cos(az);
	float ss		=sin(az);
	vec3 view		=normalize(vec3(ce*ss,ce*cs,se));
	vec4 res		=texture_cube_lod(cubeTexture,view,displayMip);
	//res.xyz=IN.texCoords.xyy;
	vec3 v = abs(view);
	float e = max(max(v.x, v.y), v.z);
	// All D components are positive. Only the smallest is equal to e. Step(x,y) returns (y>=x). So step(D.x,e) returns (e>=D.x), which is only true if e==D.x
	vec3 N = step( vec3(e, e, e), v);
	if(dot(N,view)<0)
		N=vec3(1.0,1.0,1.0)-N;
	N*=0.001;
	res				=vec4(pow(res.xyz+N,vec3(debugGamma,debugGamma,debugGamma)),0.0);
	return res;
}

shader vec4 PS_ShowCubemapArray(posTexVertexOutput IN) : SV_TARGET
{
	vec2 texc		=IN.texCoords.xy;
	float se		=texc.y*2.0-1.0;
	float ce		=cos(asin(se));
	float az		=texc.x*3.1415926536*2.0;
	float cs		=cos(az);
	float ss		=sin(az);
	vec3 view		=normalize(vec3(ce*ss,ce*cs,se));
	vec4 res		=texture_cube_lod(cubeTextureArray,vec4(view,float(displayLayer)),displayMip);
	//res.xyz=IN.texCoords.xyy;
	vec3 v	= abs(view);
	float e	= max(max(v.x, v.y), v.z);
	// All D components are positive. Only the smallest is equal to e. Step(x,y) returns (y>=x). So step(D.x,e) returns (e>=D.x), which is only true if e==D.x
	vec3 N = step( vec3(e, e, e), v);
	if(dot(N,view)<0)
		N=vec3(1.0,1.0,1.0)-N;
	N*=0.03;
	res		=vec4(pow(res.xyz,vec3(0.44,0.44,0.44))+N,0.0);
	return res;
}

struct vec3input
{
	vec3 position	: POSITION;
};

struct v2f_cubemap
{
	vec4 hPosition	: SV_POSITION;
	vec3 wDirection	: TEXCOORD0;
};

shader v2f_cubemap VS_DrawCubemap(vec3input IN) 
{
	v2f_cubemap OUT;
	OUT.hPosition	=mul(debugWorldViewProj,vec4(IN.position.xyz,1.0));
	OUT.wDirection	=normalize(IN.position.xyz);
	return OUT;
}

shader v2f_cubemap VS_DrawCubemapSphere(idOnly IN) 
{
	v2f_cubemap OUT;
	// we have (latitudes+1)*(longitudes+1)*2 id's
	uint vertex_id		=IN.vertex_id;
	uint latitude_strip	=vertex_id/(longitudes+1)/2;
	vertex_id			-=latitude_strip*(longitudes+1)*2;
	uint longitude		=vertex_id/2;
	vertex_id			-=longitude*2;
	float azimuth		=2.0*3.1415926536*float(longitude)/float(longitudes);
	float elevation		=.99*(float(latitude_strip+vertex_id)/float(latitudes+1)-0.5)*3.1415926536;
	#ifdef SFX_OPENGL
	elevation *= -1;
	#endif
	float cos_el		=cos(elevation);
	vec3 pos			=radius*vec3(sin(azimuth)*cos_el,cos(azimuth)*cos_el,sin(elevation));
	OUT.hPosition		=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
	#ifdef SFX_OPENGL
	OUT.hPosition.y *= -1;
	#endif
	OUT.wDirection		=normalize(pos.xyz);
	return OUT;
}

shader vec4 PS_DrawSphere(v2f_cubemap IN): SV_TARGET
{
	vec3 view		=IN.wDirection.xyz;
	vec4 u			=vec4(view.rgb,1.0);
	return u;
}

shader v2f VS_DrawLatLongSphere(idOnly IN) 
{
	v2f OUT;
	// we have (latitudes+1)*(longitudes+1)*2 id's
	uint vertex_id		=IN.vertex_id;
	vec3 pos;
	if(vertex_id<(latitudes+1)*(longitudes+1))
	{
		uint latitude_strip	=vertex_id/(longitudes+1);
		vertex_id			-=latitude_strip*(longitudes+1);
		uint longitude		=vertex_id;
		float azimuth		=2.0*3.1415926536*float(longitude)/float(longitudes);
		float elevation		=.999*(float(latitude_strip)/float(latitudes)-0.5)*3.1415926536;
		float cos_el		=cos(elevation);
		pos					=radius*vec3(sin(azimuth)*cos_el,-cos(azimuth)*cos_el,sin(elevation));
		float b				=latitude_strip==latitudes/2?1.0:0.2;
		OUT.colour			=multiplier*vec4(1.0,1.0,1.0,longitude>0&&longitude<(uint)longitudes?b:0.0); //Latitude Colour
		//OUT.colour		*=saturate(elevation/1.7);
	}
	else
	{
		vertex_id				-=(latitudes+1)*(longitudes+1);
		uint longitude_strip	=vertex_id/(latitudes+1);
		uint latitude			=uint(vertex_id-longitude_strip*(latitudes+1));
		float azimuth			=2.0*3.1415926536*float(longitude_strip)/float(longitudes);
		float elevation			=.999*(float(latitude)/float(latitudes)-0.5)*3.1415926536;
		float cos_el			=cos(elevation);
		pos						=radius*vec3(sin(azimuth)*cos_el,-cos(azimuth)*cos_el,sin(elevation));
		float b					=longitude_strip==0?1.0:0.2;
		OUT.colour				=multiplier*vec4(1.0,1.0,1.0,latitude>0&&latitude<latitudes?b:0.0); //Longitude Colour
	//	OUT.colour			*=saturate(elevation/1.7);
	}
	OUT.hPosition			=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
	vec4 temp				=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
	float tz				=temp.z/temp.w;
	float z					=OUT.hPosition.z/OUT.hPosition.w;
	if(tz<z)
		OUT.colour.a*=0;
	return OUT;
}

shader v2f VS_DrawQuadOnSphere(idOnly IN) 
{
	v2f OUT;
	vec3 poss[4];
	poss[0]			=vec3( 1.0,-1.0,1.0);
	poss[1]			=vec3( 1.0, 1.0,1.0);
	poss[2]			=vec3(-1.0, 1.0,1.0);
	poss[3]			=vec3(-1.0,-1.0,1.0);
	vec3 pos;
	if(IN.vertex_id<8)
	{
		uint vert		=(IN.vertex_id+1)/2;
		pos				=poss[vert%4];
		pos.xy			*=sideview;
		pos.z			=1.0;
		pos				=normalize(pos);
		OUT.colour		=debugColour;
	}
	else
	{
		uint vert		=IN.vertex_id-8;
		int axis		=int(vert/3);
		vec3 ax			=vec3(axis==0,axis==1,axis==2);
		pos				=vec3(0,0,1.0);
		if(bool(vert%2))
			pos			+=ax*sideview;
		vec4 finalCol  = vec4(0.0,0.0,0.0,1.0);
		if(axis == 0)
		{
			finalCol.xyz += vec3(0.5,0.0,0.0);
		}
		if(axis == 1)
		{
			finalCol.xyz += 0.75*vec3(0.0,0.5,0.0);
		}
		if(axis == 2)
		{
			finalCol.xyz += vec3(0.0,0.0,0.5);
		}
		OUT.colour = finalCol;
		//OUT.colour=vec4((axis==0)*vec3(1,0.5,0.5)+(axis==1)*vec3(0,1.0,0)+(axis==2)*vec3(0.5,0.5,1.0),1.0);
	}
	pos					=radius*rotate_by_quaternion(quaternion,pos);
	// The default orientation is on the equator, whereby X=East, Y=North and Z=Up.
	// The quaternion rotates from that position.
	OUT.hPosition		=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
	return OUT;
}


shader v2f VS_DrawFilledQuadOnSphere(idOnly IN)
{
	v2f OUT;
	vec3 poss[4];
	poss[1] = vec3(1.0, -1.0, 1.0);
	poss[0] = vec3(1.0, 1.0, 1.0);
	poss[2] = vec3(-1.0, 1.0, 1.0);
	poss[3] = vec3(-1.0, -1.0, 1.0);
	vec3 pos;
	uint vert = (IN.vertex_id ) ;
	pos = poss[vert % 4];
	pos.xy *= sideview;
	pos.z = 1.0;
	pos = normalize(pos);
	OUT.colour = multiplier;
	pos = radius * rotate_by_quaternion(quaternion, pos);
	OUT.hPosition = mul(debugWorldViewProj, vec4(pos.xyz, 1.0));
	return OUT;
}

shader v2f VS_DrawCircleOnSphere(idOnly IN) 
{
	v2f OUT;
	float angle			=float(IN.vertex_id)/31.0*3.1415926536*2.0;
	vec3 pos			=vec3(sideview*cos(angle), sideview*sin(angle),1.0);
	pos					=normalize(pos);
	OUT.colour			=debugColour;
	
	pos					=radius*rotate_by_quaternion(quaternion,pos);
	// The default orientation is on the equator, whereby X=East, Y=North and Z=Up.
	// The quaternion rotates from that position.
	OUT.hPosition		=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
	return OUT;
}

shader v2f VS_DrawFilledCircleOnSphere(idOnly IN)
{
	v2f OUT;
	float angle = float(IN.vertex_id/2) / 31.0*3.1415926536*2.0;
	float mult = float(IN.vertex_id % 2);
	vec3 pos = vec3(mult*sideview*cos(angle),mult*sideview*sin(angle), 1.0);
	pos = normalize(pos);
	OUT.colour = multiplier;

	pos = radius * rotate_by_quaternion(quaternion, pos);
	// The default orientation is on the equator, whereby X=East, Y=North and Z=Up.
	// The quaternion rotates from that position.
	OUT.hPosition = mul(debugWorldViewProj, vec4(pos.xyz, 1.0));
	return OUT;
}

shader posTexVertexOutput VS_DrawTextureOnSphere(idOnly IN) 
{
	posTexVertexOutput OUT;
	vec3 poss[4];
	poss[0]			=vec3( 1.0,-1.0,1.0);
	poss[1]			=vec3( 1.0, 1.0,1.0);
	poss[2]			=vec3(-1.0, 1.0,1.0);
	poss[3]			=vec3(-1.0,-1.0,1.0);
	vec3 pos;
	uint vert=IN.vertex_id%4;
	{
		pos				=poss[vert];
		OUT.texCoords	=pos.xy*0.5+vec2(0.5,0.5);
		pos.xy			*=sideview;
		pos.z			=1.0;
		pos				=normalize(pos);
	}
	pos					=radius*rotate_by_quaternion(quaternion,pos);
	// The default orientation is on the equator, whereby X=East, Y=North and Z=Up.
	// The quaternion rotates from that position.
	OUT.hPosition		=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
	return OUT;
}

shader vec4 PS_DrawTextureOnSphere(posTexVertexOutput IN) : SV_TARGET
{
	vec2 texc	=IN.texCoords.xy;
	// In DX, texcoords start from top left. In GL, sensibly, it's bottom-left.
	texc.y		=1.0-texc.y;
	vec4 res	=multiplier*texture_nearest_lod(imageTexture,texc.xy,0);
	//res.rgb=IN.texCoords.xyy;
	return res;
}


shader vec4 PS_DrawCubemap(v2f_cubemap IN): SV_TARGET
{
	vec3 view		=IN.wDirection.xyz;
	vec4 result		=cubeTexture.SampleLevel(cubeSamplerState,view,displayMip);
	result.rgb		*=multiplier.rgb;
	result.rgb		=pow(result.rgb,vec3(debugGamma,debugGamma,debugGamma));
	vec4 u			=vec4(saturate(result.rgb),1.0);
	return u;
}

shader vec4 PS_ShowTexture(posTexVertexOutput IN) : SV_TARGET
{
	vec2 texc	=IN.texCoords.xy;
	// In DX, texcoords start from top left. In GL, sensibly, it's bottom-left.
	texc.y		=1.0-texc.y;
	texc.xy		=viewport.xy+texc.xy*viewport.zw;
	vec4 res	=multiplier*texture_nearest_lod(imageTexture,texc.xy,0);
	res.rgb		=pow(res.rgb,vec3(debugGamma,debugGamma,debugGamma));
	res.rgb		+=res.aaa;
	DETECT_NANS(texc, res.rgb);
	return res;
}

shader vec4 PS_ShowTextureArray(posTexVertexOutput IN) : SV_TARGET
{
	vec3 texc	= vec3(IN.texCoords.xy, float(displayLayer));
	// In DX, texcoords start from top left. In GL, sensibly, it's bottom-left.
	texc.y		= 1.0 - texc.y;
	vec4 res	= multiplier * texture_nearest_lod(imageTextureArray,texc.xyz,0);
	res.rgb		= pow(res.rgb, vec3(debugGamma, debugGamma, debugGamma));
	res.rgb		+= res.aaa;
	DETECT_NANS(texc, res.rgb);
	return res;
}

shader vec4 PS_ShowTextureRadial(posTexVertexOutput IN) : SV_TARGET
{
	vec2 offs	=IN.texCoords.xy-vec2(.5,.5);
	float rad	=length(offs)/0.5;
	float azim	=frac(atan2(offs.x,offs.y)/(2.0*3.1415926536));
	vec2 texc	=vec2(azim,rad);
	vec4 res	=texture_nearest_lod(imageTexture,texc.xy,0);
	res			*=step(rad,1.0);
	//res.rgb=IN.texCoords.xyy;
	DETECT_NANS(texc, res.rgb);
	return res;
}

shader vec4 PS_Untextured(posTexVertexOutput IN) : SV_TARGET
{
	vec4 res	=multiplier;
	return res;
}

vec2 Parametric2DCoord(vec2 x,vec2 y,vec2 p)
{
	float det=x.x*y.y-(x.y*y.x);
	vec2 c=vec2(dot(p,vec2(y.y,-y.x)),dot(p,vec2(-x.y,x.x)))/det;
	return c;
}

shader vec4 PS_ShowVolume(posTexVertexOutput IN) : SV_Target
{
	vec2 c		=vec2(0.6,0.7);
	vec2 texc	=IN.texCoords.xy-c;
	vec2 x		=vec2(0.4,0.18);
	vec2 y		=vec2(-0.6,0.125);
	vec2 z		=vec2(0,-0.7);
	vec3 X		=vec3(Parametric2DCoord(y,z,texc),0.0);
	X			=X.zxy;
	X.z			=1.0-X.z;
	vec3 Y		=vec3(Parametric2DCoord(x,z,texc),0.0);
	Y			=Y.xzy;
	Y.z			=1.0-Y.z;
	vec3 Z		=vec3(Parametric2DCoord(x,y,texc),1.0);
	vec4 res	=vec4(0,0,0,0);
	
	if(X.z>0&&X.z<1.0&&X.y>0&&X.y<1.0)
	{
		res.rgb= multiplier.rgb*texture_3d_nearest_lod(volumeTexture,X,0).rgb;
		res.rgb+=0.05;
		res.rgb+=vec3(0.1,0,0);
	}
	if(Y.x>0&&Y.x<1.0&&Y.z>0&&Y.z<1.0)
	{
		res.rgb= multiplier.rgb * texture_3d_nearest_lod(volumeTexture,Y,0).rgb;
		res.rgb+=vec3(0,0.1,0);
	}
	if(Z.x>0&&Z.x<1.0&&Z.y>0&&Z.y<1.0)
	{
		res.rgb= multiplier.rgb * texture_3d_nearest_lod(volumeTexture,Z,0).rgb;
		res.rgb+=0.1;
		res.rgb+=vec3(0,0,0.1);
	}
	DETECT_NANS(texc,res.rgb);
//	res=vec4(texc,0,0);
	return res;
}

shader vec4 PS_TraceVolume(posTexVertexOutput IN) : SV_Target
{
	vec3 volumeSize;
	volumeTexture.GetDimensions(volumeSize.x, volumeSize.y, volumeSize.z);
	vec3 texc = vec3(IN.texCoords.xy, float(displayLayer)/volumeSize.z);
	vec4 colour = texture_3d_wrap_lod(volumeTexture, texc, 0);
	colour *= multiplier;
	return colour;
}

#ifndef GLSL
shader vec4 PS_CompactedTexture(posTexVertexOutput IN) : SV_TARGET
{
	return texture_int(imageTextureUint,IN.texCoords.xy);
}
#endif

shader vec4 PS_ShowTextureMS(posTexVertexOutput IN) : SV_TARGET
{
	uint2 dims;
	uint numSamples;
	GET_DIMENSIONS_MSAA(imageTextureMS,dims.x,dims.y,numSamples);
	int2 pos	=int2(IN.texCoords.xy*vec2(dims.xy));
	vec4 res	=multiplier*imageTextureMS.Load(pos,0);
	return res;
}

vec4 ShowDepthPS(posTexVertexOutput IN,bool reverseDepth) 
{
	vec2 texc=IN.texCoords.xy;
	// In DX, texcoords start from top left. In GL, sensibly, it's bottom-left.
	texc.y			=1.0-texc.y;
	vec4 depth		=texture_nearest_lod(imageTexture,texc,0);

	DepthInterpretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=debugDepthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	vec4 dist		=depthToFadeDistance(depth,2.0*(IN.texCoords-0.5),depthInterpretationStruct,debugTanHalfFov);
	if(texc.x>.5)
		dist.xy		=dist.zw;
	dist.z			=0;
	vec4 result		=vec4(pow(dist.xyz,vec3(0.44,0.44,0.44)),1.0);
	if (depth.x <= 0)
		return vec4(1, 0, 0, 0);
	if (depth.x== 1.0)
		return vec4(0, 0, 1, 0);
	return result;
}

shader vec4 PS_ShowDepth_Forward(posTexVertexOutput IN) : SV_TARGET
{
	vec4 res=ShowDepthPS(IN,false);
	return res;
}

shader vec4 PS_ShowDepth_Reverse(posTexVertexOutput IN) : SV_TARGET
{
	vec4 res=ShowDepthPS(IN,true);
	return res;
}

shader vec4 PS_ShowDepthCube_Forward(posTexVertexOutput IN) : SV_TARGET
{
	vec4 res=ShowDepthCube(IN,false);
	return res;
}

shader vec4 PS_ShowDepthCube_Reverse(posTexVertexOutput IN) : SV_TARGET
{
	vec4 res=ShowDepthCube(IN,true);
	return res;
}

vec4 ShowDepthMS_PS(posTexVertexOutput IN,bool reverseDepth) 
{
	vec2 texc=IN.texCoords.xy;

	// In DX, texcoords start from top left. In GL, sensibly, it's bottom-left.
	texc.y		=1.0-texc.y;

	uint2 dims;
	uint numSamples;
	GET_DIMENSIONS_MSAA(imageTextureMS,dims.x,dims.y,numSamples);
	int2 pos		=int2(texc.xy*vec2(dims.xy));
	vec4 depth		=TEXTURE_LOAD_MSAA(imageTextureMS,pos,0);
	DepthInterpretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=debugDepthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	vec2 dist		=depthToFadeDistance(depth.xx,2.0*(texc-0.5),depthInterpretationStruct,debugTanHalfFov);
	vec4 result=vec4(pow(dist.xy,vec2(0.44,0.44)),depth.z,1.0);
	if(IN.texCoords.x<viewport.x||IN.texCoords.x>viewport.x+viewport.z
		||IN.texCoords.y<viewport.y||IN.texCoords.y>viewport.y+viewport.w)
		result*=0.25;
	result.b+=1;
	return result;
}

shader vec4 PS_ShowDepthMS_Forward(posTexVertexOutput IN) : SV_TARGET
{
	vec4 res=ShowDepthMS_PS(IN,false);
	return res;
}

shader vec4 PS_ShowDepthMS_Reverse(posTexVertexOutput IN) : SV_TARGET
{
	vec4 res=ShowDepthMS_PS(IN,true);
	return res;
}

shader v2f Vec3InputSignatureVS(vec3input IN)
{
	v2f OUT;
	OUT.hPosition=mul(debugWorldViewProj,vec4(IN.position.xyz,1.0));
	OUT.colour = vec4(1.0,1.0,1.0,1.0);
	return OUT;
}

shader posTexVertexOutput VS_DepthWrite(idOnly IN)
{
	posTexVertexOutput OUT;
	vec2 poss[4];
	poss[0]=vec2( 1.0,-1.0);
	poss[1]=vec2( 1.0, 1.0);
	poss[2]=vec2(-1.0,-1.0);
	poss[3]=vec2(-1.0, 1.0);
	vec2 pos		=poss[IN.vertex_id];
	OUT.hPosition	=vec4(pos,0.0,1.0);
	OUT.hPosition.z	=debugDepth; 
	OUT.texCoords	=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
	return OUT;
}

VertexShader vs_quad_5_0=CompileShader(vs_5_0,VS_Quad());
VertexShader debugvs_5_0=CompileShader(vs_5_0,DebugVS());
PixelShader debugps_5_0=CompileShader(ps_5_0,DebugPS());
VertexShader vs_simplefullscreen_5_0=CompileShader(vs_5_0,VS_SimpleFullscreen());
VertexShader vs_ultrasimplefullscreen_5_0=CompileShader(vs_5_0,VS_UltraSimpleFullscreen());


shader v2f LinesNoVBVS(idOnly IN)
{
	v2f OUT;
	vec3 poss[2];
	poss[0]			=line_start;
	poss[1]			=line_end;
	vec3 pos		=poss[IN.vertex_id];
	OUT.hPosition	=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
	OUT.colour		=debugColour;
	return OUT;
}
shader v2f AxesVS(idOnly IN)
{
	v2f OUT;
	vec3 poss[12];
	poss[0]			=vec3(0,0,0);
	poss[2]			=vec3(0,0,0);
	poss[4]			=vec3(0,0,0);
	poss[1]			=vec3(1.0,0,0);
	poss[3]			=vec3(0,1.0,0);
	poss[5]			=vec3(0,0,1.0);
	vec3 pos		=radius*poss[IN.vertex_id];
	OUT.hPosition	=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
	vec4 colours[3];
	colours[0]=vec4(1.0,0.2,0.2,1.0);
	colours[1]=vec4(0,1.0,0,1.0);
	colours[2]=vec4(0,0.4,1.0,1.0);
	OUT.colour		=colours[IN.vertex_id/2];
	return OUT;
}
VertexShader lines_novb=CompileShader(vs_5_0,LinesNoVBVS());
VertexShader axesvs_5_0=CompileShader(vs_5_0,AxesVS());
PixelShader axesps_5_0=CompileShader(ps_5_0,DebugPS());
technique axes
{
	pass p0
	{
		SetRasterizerState( wireframeRasterizer );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(axesvs_5_0);
		SetPixelShader(axesps_5_0);
	}
}
technique lines_3d
{
	pass lines3d_novb
	{
		SetRasterizerState( wireframeRasterizer );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(lines_novb);
		SetPixelShader(debugps_5_0);
	}
	pass lines3d_nodepth
	{
		SetRasterizerState( wireframeRasterizer );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AddBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(debugvs_5_0);
		SetPixelShader(debugps_5_0);
	}
	pass lines3d_forwarddepth
	{
		SetRasterizerState(wireframeRasterizer);
		SetDepthStencilState(TestForwardDepth,0);
		SetBlendState(AddBlend,vec4(0.0,0.0,0.0,0.0),0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(debugvs_5_0);
		SetPixelShader(debugps_5_0);
	}
	pass lines3d_reversedepth
	{
		SetRasterizerState( wireframeRasterizer );
		SetDepthStencilState( TestReverseDepth, 0 );
		SetBlendState(AddBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(debugvs_5_0);
		SetPixelShader(debugps_5_0);
	}
}

technique lines_2d
{
	pass p0
	{
		SetRasterizerState( wireframeRasterizer );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,Debug2dVS()));
		SetPixelShader(debugps_5_0);
	}
	pass p1
	{
		SetRasterizerState(wireframeRasterizer);
		SetDepthStencilState(DisableDepth, 0);
		SetBlendState(AlphaBlend, vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0, Debug2dVS()));
		SetPixelShader(CompileShader(ps_5_0, DebugFP16PS()));
	}
}
fxgroup circle
{
	technique outline
	{
		pass p0
		{
			SetRasterizerState( wireframeRasterizer );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(CompileShader(vs_5_0,CircleVS()));
			SetPixelShader(debugps_5_0);
		}
	}
	technique filled
	{
		pass p0
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(CompileShader(vs_5_0,FilledCircleVS()));
			SetPixelShader(debugps_5_0);
		}
	}
}


shader vec4 PS_Copy2D(posTexVertexOutput IN) : SV_TARGET
{
	vec2 texc	=IN.texCoords.xy;
	vec4 res	=texture_clamp_lod(imageTexture,texc.xy,0);
	return res;
}

shader vec4 PS_Copy2DWrap(posTexVertexOutput IN) : SV_TARGET
{
	vec2 texc	=IN.texCoords.xy;
	vec4 res	=texture_wrap_lod(imageTexture,texc.xy,0);
	return res;
}

shader vec4 PS_Copy2DOffset(posTexVertexOutput IN) : SV_TARGET
{
	vec2 texc	=frac((IN.texCoords.xy+rect.xy)*rect.zw);
	vec4 res	=texture_clamp_lod(imageTexture,texc.xy,0);
	return res;
}
 
shader vec4 PS_Clear(posTexVertexOutput IN) : SV_TARGET
{
	vec4 ret= debugColour;
	return ret;
}

shader vec4 PS_UltraSimpleClear(posVertexOutput IN) : SV_TARGET
{
	vec4 res=debugColour;
	return res;
}

shader vec4 PS_UltraSimpleClear_MV(posVertexOutput IN, uint viewID : SV_ViewID) : SV_TARGET
{
	vec4 ret = debugColour;
	//ret.g = viewID == 1 ? 1.0 - ret.g : ret.g;
	return ret;
}

shader vec4 PS_HeightToNormal(posTexVertexOutput IN) : SV_TARGET
{
	float me = imageTexture.SampleLevel(wrapSamplerState,IN.texCoords,0).x;
	vec2 sz	=vec2(texSize.xy);
	float n =imageTexture.SampleLevel(wrapSamplerState,IN.texCoords+vec2(0, 2.0/sz.y),0).x;
	float s =imageTexture.SampleLevel(wrapSamplerState,IN.texCoords+vec2(0,-2.0/sz.y),0).x;
	float e =imageTexture.SampleLevel(wrapSamplerState,IN.texCoords+vec2( 2.0/sz.x,0),0).x;
	float w =imageTexture.SampleLevel(wrapSamplerState,IN.texCoords+vec2(-2.0/sz.x,0),0).x;
	
	// defining starting normal as color has some interesting effects, generally makes this more flexible
	vec3 norm = vec3(0.5,0.5,1.0);
	vec3 temp = norm; //a temporary vector that is not parallel to norm
	if (norm.x == 1.0)
		temp.y += 0.5;
	else
		temp.x += 0.5;
	
	//form a basis with norm being one of the axes:
	vec3 perp1 = vec3(0,1.0,0);
	vec3 perp2 = vec3(1.0,0,0);
	
	//use the basis to move the normal i its own space by the offset
	vec3 normalOffset = -multiplier.xyz * vec3(e-w,n-s,0);
	norm += normalOffset;
	return vec4(norm,0);
}

[numthreads(4,4,1)]
shader void CS_LatLongToCubemap(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 idx = g.xyz*uint3(4,4,1)+ t.xyz;
	// convert xyz to a direction.
	uint3 dims;
	FastClearTarget2DArray.GetDimensions(dims.x,dims.y,dims.z);
	vec2 texCoords = (vec2(idx.xy) + vec2(0.5, 0.5)) / vec2(dims.xy);
	vec4 clip_pos = vec4(-1.0, 1.0, 1.0, 1.0);
	clip_pos.x += 2.0*texCoords.x;
	clip_pos.y -= 2.0*texCoords.y;
#ifdef GLSL
	clip_pos.xy*=-1.0;
#endif
	vec3 view = normalize(mul(GetCubeInvViewProj(idx.z), clip_pos).xyz);
	//vec3 view=CubeFaceIndexToView(idx,dims.xx);
	// convert direction to lat long
	float lat=asin(view.z);
	float lon=atan2(view.x,view.y);
	vec2 texc = vec2(lon / (2.0*SIMUL_PI_F), lat*2.0 / SIMUL_PI_F*0.5 + 0.5);
	vec4 lookup=imageTexture.SampleLevel(wmcSamplerState,texc,0);
	// lookup in source texture
	// write to position in target.
	FastClearTarget2DArray[idx]= vec4(saturate(lookup.xyz),0.5);
}

[numthreads(8,8,1)]
shader void CS_Clear(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint2 sub_pos = g.xy * 8 + t.xy;
	if(sub_pos.x<texSize.x&&sub_pos.y<texSize.y)
	{
		FastClearTarget[sub_pos] = debugColour;
	}
}

[numthreads(8,8,1)]
shader void CS_Clear2DArray(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 sub_pos =uint3(g.xy * 8 + t.xy,t.z);
	if(sub_pos.x<texSize.x&&sub_pos.y<texSize.y)
		FastClearTarget2DArray[sub_pos] = debugColour;
}
[numthreads(8,8,1)]
shader void CS_Clear2DArray_U8(uint3 g : SV_GroupID,uint3 t : SV_GroupThreadID)
{
	uint3 sub_pos =uint3(g.xy * 8 + t.xy,t.z);
	if(sub_pos.x<texSize.x&&sub_pos.y<texSize.y)
		FastClearTarget2DArrayU8[sub_pos] = debugColour;
}

[numthreads(4,4,4)]
shader void CS_Clear3D(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 sub_pos = g * 4 + t;
	if(sub_pos.x<texSize.x&&sub_pos.y<texSize.y&&sub_pos.z<texSize.z)
	{
		FastClearTarget3D[sub_pos] = debugColour;
	}
}
[numthreads(4, 4, 4)]
shader void CS_Clear3D_U8(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 sub_pos = g * 4 + t;
	if (sub_pos.x<texSize.x&&sub_pos.y<texSize.y&&sub_pos.z<texSize.z)
	{
		FastClearTarget3DU8[sub_pos] = debugColour;
	}
}

[numthreads(1,1,1)]
shader void CS_TexelQuery(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 sub_pos = g + t;
	textureQueryResults[sub_pos.x]=imageTexture[queryPos];
}

technique copy_2d
{
	pass wrap
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_simplefullscreen_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_Copy2DWrap()));
	}
	pass replace
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_simplefullscreen_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_Copy2D()));
	}
	pass add
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AddBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_simplefullscreen_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_Copy2D()));
	}
	pass offset
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_simplefullscreen_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_Copy2DOffset()));
	}
}

technique lat_long_to_cubemap
{
	pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_LatLongToCubemap()));
	}
}

technique compute_clear
{
	pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Clear()));
	}
}

technique compute_clear_2d_array
{
	pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Clear2DArray()));
	}
}

technique compute_clear_2d_array_u8
	{
		pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Clear2DArray_U8()));
	}
}

technique compute_clear_3d
{
	pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Clear3D()));
	}
}

technique compute_clear_3d_u8
{
	pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Clear3D_U8()));
	}
}

technique texel_query
{
	pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_TexelQuery()));
	}
}

technique clear
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_ultrasimplefullscreen_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_UltraSimpleClear()));
	}
}

technique clear_multiview
{
	pass p0
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(DisableDepth, 0);
		SetBlendState(DontBlend, vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetGeometryShader(NULL);
		SetVertexShader(vs_ultrasimplefullscreen_5_0);
		SetPixelShader(CompileShader(ps_6_1, PS_UltraSimpleClear_MV()));
	}
}

technique height_to_normal
{
	pass p0
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(DisableDepth, 0);
		SetBlendState(DontBlend, vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetGeometryShader(NULL);
		SetVertexShader(vs_simplefullscreen_5_0);
		SetPixelShader(CompileShader(ps_5_0, PS_HeightToNormal()));
	}
}

BlendState DontWriteColour
{
	BlendEnable[0]	=FALSE;
	RenderTargetWriteMask[0]=0;
};
 
technique clear_depth
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontWriteColour, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_simplefullscreen_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_Clear()));
	}
}

technique clear_both
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( WriteDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_DepthWrite()));
		SetPixelShader(CompileShader(ps_5_0,PS_Clear()));
	}
}

technique clear_colour
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_simplefullscreen_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_Clear()));
	}
}

BlendState AlphaBlendNoAlphaWrite
{
	BlendEnable[0]	=TRUE;
	SrcBlend		=SRC_ALPHA;
	DestBlend		=INV_SRC_ALPHA;
	RenderTargetWriteMask[0]=7;
};

BlendState NoBlendNoAlphaWrite
{
	BlendEnable[0] = FALSE;
	RenderTargetWriteMask[0]=7;
	SrcBlend			= ONE;
	DestBlend			= ZERO;
};

BlendState NoBlendSetAlpha
{
	BlendEnable[0] = FALSE;
	RenderTargetWriteMask[0]=15;
	SrcBlend			= ONE;
	DestBlend			= ZERO;
	BlendOp				= ADD;
	SrcBlendAlpha		= ZERO;
	DestBlendAlpha		= ZERO;
	BlendOpAlpha		= ADD;
};

technique show_cubemap_array
{
	pass noblend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendSetAlpha, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowCubemapArray()));
	}
	pass blend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowCubemapArray()));
	}
}

technique show_texture
{
	pass noblend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowTexture()));
	}
	pass blend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowTexture()));
	}
}

technique show_texture_array
	{
		pass noblend
		{
			SetRasterizerState(RenderNoCull);
			SetDepthStencilState(DisableDepth, 0);
			SetBlendState(NoBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF);
			SetGeometryShader(NULL);
			SetVertexShader(vs_quad_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_ShowTextureArray()));
		}
		pass blend
		{
			SetRasterizerState(RenderNoCull);
			SetDepthStencilState(DisableDepth, 0);
			SetBlendState(AlphaBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF);
			SetGeometryShader(NULL);
			SetVertexShader(vs_quad_5_0);
			SetPixelShader(CompileShader(ps_5_0, PS_ShowTextureArray()));
		}
	}

technique show_cubemap
{
	pass noblend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendSetAlpha, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowCubemap()));
	}
	pass blend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowCubemap()));
	}
}

technique radial
{
	pass noblend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendSetAlpha, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowTextureRadial()));
	}
	pass blend
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(DisableDepth, 0);
		SetBlendState(AlphaBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF);
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowTextureRadial()));
	}
}

technique textured
{
	pass noblend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendSetAlpha, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowTexture()));
	}
	pass blend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowTexture()));
	}
}

technique untextured
{
	pass noblend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_Untextured()));
	}
	pass blend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_Untextured()));
	}
}

technique show_volume
{
	pass noblend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowVolume()));
	}
	pass blend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowVolume()));
	}
}

technique trace_volume
	{
		pass noblend
		{
			SetRasterizerState(RenderNoCull);
			SetDepthStencilState(DisableDepth, 0);
			SetBlendState(NoBlendNoAlphaWrite,vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
			SetGeometryShader(NULL);
			SetVertexShader(vs_quad_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_TraceVolume()));
		}
		pass blend
		{
			SetRasterizerState(RenderNoCull);
			SetDepthStencilState(DisableDepth, 0);
			SetBlendState(AlphaBlend,vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
			SetGeometryShader(NULL);
			SetVertexShader(vs_quad_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_TraceVolume()));
		}
	}

technique texturedMS
{
	pass noblend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowTextureMS()));
	}
}


technique vec3_input_signature
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,Vec3InputSignatureVS()));
		SetPixelShader(debugps_5_0);
	}
}

technique draw_cubemap
{
	pass noblend 
	{		
		SetRasterizerState( RenderFrontfaceCull );
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_DrawCubemap()));
		SetPixelShader(CompileShader(ps_5_0,PS_DrawCubemap()));
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
	}
	pass blend  
	{		
		SetRasterizerState( RenderFrontfaceCull );
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_DrawCubemap()));
		SetPixelShader(CompileShader(ps_5_0,PS_DrawCubemap()));
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
	}
}

technique draw_cubemap_sphere
{
	pass noblend
	{		
		SetRasterizerState( RenderBackfaceCull );
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_DrawCubemapSphere()));
		SetPixelShader(CompileShader(ps_5_0,PS_DrawCubemap()));
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite,vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
	}
}

technique draw_lat_long_sphere
{
	pass noblend
	{		
		SetRasterizerState( RenderBackfaceCull );
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_DrawLatLongSphere()));
		SetPixelShader(debugps_5_0);
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend,vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
	}
}

technique draw_quad_on_sphere
{
	pass fill
	{
		SetRasterizerState(RenderNoCull);
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_DrawFilledQuadOnSphere()));
		SetPixelShader(debugps_5_0);
		SetDepthStencilState(DisableDepth, 0);
		SetBlendState(AlphaBlend,vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF);
	}
	pass outline
	{		
		SetRasterizerState(RenderNoCull);
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_DrawQuadOnSphere()));
		SetPixelShader(debugps_5_0);
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AddBlend,vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
	}
}

technique draw_texture_on_sphere
{
	pass p0 
	{		
		SetRasterizerState( RenderNoCull );
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_DrawTextureOnSphere()));
		SetPixelShader(CompileShader(ps_5_0,PS_DrawTextureOnSphere()));
		//SetVertexShader(CompileShader(vs_5_0,VS_DrawQuadOnSphere()));
		//SetPixelShader(debugps_5_0);
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
	}
}

technique draw_circle_on_sphere
{
	pass fill 
	{		
		SetRasterizerState(RenderNoCull);
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_DrawFilledCircleOnSphere()));
		SetPixelShader(debugps_5_0);
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend,vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
	}
	pass outline
	{
		SetRasterizerState(RenderNoCull);
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_DrawCircleOnSphere()));
		SetPixelShader(debugps_5_0);
		SetDepthStencilState(DisableDepth, 0);
		SetBlendState(AddBlend,vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF);
	}
}


technique draw_sphere
{
	pass p0 
	{		
		SetRasterizerState( RenderBackfaceCull );
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_DrawCubemapSphere()));
		SetPixelShader(CompileShader(ps_5_0,PS_DrawSphere()));
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
	}
}

technique show_depth
{
	pass reverse_depth
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowDepth_Reverse()));
	}
	pass forward_depth
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowDepth_Forward()));
	}
}
technique show_depth_cube
{
	pass reverse_depth
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowDepthCube_Reverse()));
	}
	pass forward_depth
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowDepthCube_Forward()));
	}
}

technique show_depth_ms
{
	pass reverse_depth
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowDepthMS_Reverse()));
	}
	pass forward_depth
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowDepthMS_Forward()));
	}
}
#ifndef GLSL
technique compacted_texture
{
	pass noblend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_CompactedTexture()));
	}
	pass blend
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlendNoAlphaWrite, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(vs_quad_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_CompactedTexture()));
	}
}
#endif